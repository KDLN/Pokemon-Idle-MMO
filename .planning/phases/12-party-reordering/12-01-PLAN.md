---
phase: 12-party-reordering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/game-server/src/db.ts
  - apps/game-server/src/hub.ts
  - apps/web/src/lib/ws/gameSocket.ts
autonomous: true

must_haves:
  truths:
    - "Server accepts reorder_party message with array of 6 Pokemon IDs"
    - "Server validates ownership and party membership before updating"
    - "Server broadcasts party_update to all player sessions after reorder"
    - "Client can send reorder request via gameSocket.reorderParty()"
  artifacts:
    - path: "apps/game-server/src/db.ts"
      provides: "reorderParty database function"
      exports: ["reorderParty"]
    - path: "apps/game-server/src/hub.ts"
      provides: "reorder_party message handler"
      contains: "case 'reorder_party'"
    - path: "apps/web/src/lib/ws/gameSocket.ts"
      provides: "reorderParty client method"
      contains: "reorderParty"
  key_links:
    - from: "apps/web/src/lib/ws/gameSocket.ts"
      to: "apps/game-server/src/hub.ts"
      via: "WebSocket message reorder_party"
      pattern: "send.*reorder_party"
    - from: "apps/game-server/src/hub.ts"
      to: "apps/game-server/src/db.ts"
      via: "reorderParty function call"
      pattern: "reorderParty\\("
---

<objective>
Add backend infrastructure for party reordering: database function, WebSocket handler, and client method.

Purpose: Enable the frontend to persist party order changes to the database with proper validation and cross-tab sync.
Output: Working backend endpoint that accepts party reorder requests and broadcasts updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-party-reordering/12-CONTEXT.md
@.planning/phases/12-party-reordering/12-RESEARCH.md

# Key existing files
@apps/web/package.json
@apps/game-server/src/db.ts (lines 455-489 for existing swap/remove functions)
@apps/game-server/src/hub.ts (lines 1022-1084 for existing handlers)
@apps/web/src/lib/ws/gameSocket.ts (lines 321-330 for existing party methods)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @dnd-kit packages</name>
  <files>apps/web/package.json</files>
  <action>
Install the @dnd-kit packages in the web app:

```bash
cd apps/web && npm install @dnd-kit/core@^6.3.1 @dnd-kit/sortable@^10.0.0 @dnd-kit/utilities@^3.2.2
```

This adds the drag-and-drop library that will be used in Plan 02. Installing now ensures dependencies are ready.
  </action>
  <verify>
Run `npm ls @dnd-kit/core` in apps/web and confirm version 6.x is installed.
  </verify>
  <done>@dnd-kit/core, @dnd-kit/sortable, and @dnd-kit/utilities appear in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Add reorderParty database function</name>
  <files>apps/game-server/src/db.ts</files>
  <action>
Add a new `reorderParty` function after the existing `removeFromParty` function (around line 489):

```typescript
/**
 * Reorder party Pokemon to new positions
 * @param playerId - Owner of the Pokemon
 * @param newOrder - Array of 6 Pokemon IDs (null for empty slots)
 * @returns true if successful, false if validation fails
 */
export async function reorderParty(
  playerId: string,
  newOrder: (string | null)[]
): Promise<boolean> {
  // Validate array length
  if (newOrder.length !== 6) return false

  // Get current party to validate ownership
  const { data: currentParty, error: fetchError } = await supabase
    .from('pokemon')
    .select('id')
    .eq('owner_id', playerId)
    .not('party_slot', 'is', null)

  if (fetchError) return false

  // Validate all non-null IDs are in current party
  const currentPartyIds = new Set(currentParty?.map(p => p.id) || [])
  const newPartyIds = newOrder.filter((id): id is string => id !== null)

  for (const id of newPartyIds) {
    if (!currentPartyIds.has(id)) return false
  }

  // Update each pokemon's party_slot atomically
  // First, clear all party slots for this player's party Pokemon
  await supabase
    .from('pokemon')
    .update({ party_slot: null })
    .eq('owner_id', playerId)
    .not('party_slot', 'is', null)

  // Then set new positions
  for (let slot = 1; slot <= 6; slot++) {
    const pokemonId = newOrder[slot - 1]
    if (pokemonId) {
      const { error } = await supabase
        .from('pokemon')
        .update({ party_slot: slot })
        .eq('id', pokemonId)
        .eq('owner_id', playerId)

      if (error) return false
    }
  }

  return true
}
```

Key validation rules:
1. Array must be exactly 6 elements
2. All non-null IDs must belong to player's current party
3. Updates happen atomically (clear all, then set new positions)
  </action>
  <verify>
TypeScript compiles without errors: `cd apps/game-server && npx tsc --noEmit`
  </verify>
  <done>reorderParty function exists in db.ts with ownership validation</done>
</task>

<task type="auto">
  <name>Task 3: Add reorder_party WebSocket handler</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
1. Add import for reorderParty at the top with other db imports:
   ```typescript
   import { reorderParty } from './db'
   ```

2. Add case in the message switch statement (around line 486, after remove_from_party):
   ```typescript
   case 'reorder_party':
     this.handleReorderParty(client, msg.payload as { order: (string | null)[] })
     break
   ```

3. Add handler method after handleRemoveFromParty (around line 1085):
   ```typescript
   private async handleReorderParty(client: Client, payload: { order: (string | null)[] }) {
     if (!client.session) return

     // Check if in active battle
     if (client.session.encounter) {
       this.sendError(client, 'Cannot reorder party during battle')
       return
     }

     const success = await reorderParty(
       client.session.player.id,
       payload.order
     )

     if (!success) {
       this.sendError(client, 'Failed to reorder party')
       return
     }

     // Reload party
     client.session.party = await getPlayerParty(client.session.player.id)

     // Broadcast to all sessions for this player (cross-tab sync)
     this.broadcastToPlayer(client.session.player.id, 'party_update', {
       party: client.session.party
     })
   }
   ```

4. Add broadcastToPlayer helper method if it doesn't exist:
   ```typescript
   private broadcastToPlayer(playerId: string, type: string, payload: unknown) {
     for (const [, c] of this.clients) {
       if (c.session?.player.id === playerId) {
         this.send(c, type, payload)
       }
     }
   }
   ```

The handler:
- Blocks reordering during active battle
- Validates via reorderParty function
- Broadcasts to ALL player sessions (cross-tab sync per CONTEXT.md)
  </action>
  <verify>
TypeScript compiles without errors: `cd apps/game-server && npx tsc --noEmit`
  </verify>
  <done>reorder_party case exists in switch, handleReorderParty method implemented with battle check</done>
</task>

<task type="auto">
  <name>Task 4: Add reorderParty client method</name>
  <files>apps/web/src/lib/ws/gameSocket.ts</files>
  <action>
Add a new method after the existing removeFromParty method (around line 330):

```typescript
// Reorder party Pokemon
// order: Array of 6 Pokemon IDs (null for empty slots), in desired position order
// Returns true if message sent, false if not connected
reorderParty(order: (string | null)[]): boolean {
  if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
    return false
  }
  this.send('reorder_party', { order })
  return true
}
```

This method:
- Accepts the new party order as array of 6 IDs (null for empty slots)
- Returns boolean to indicate if message was sent (for optimistic update rollback)
- Matches the payload shape expected by hub.ts handler
  </action>
  <verify>
TypeScript compiles without errors: `cd apps/web && npx tsc --noEmit`
  </verify>
  <done>gameSocket.reorderParty() method exists and accepts order array</done>
</task>

</tasks>

<verification>
1. All TypeScript compiles without errors in both apps
2. @dnd-kit packages are installed in apps/web
3. reorderParty function exists in db.ts
4. reorder_party case exists in hub.ts message handler
5. gameSocket.reorderParty method exists
</verification>

<success_criteria>
- Backend can receive reorder_party WebSocket message
- Database function validates ownership and updates party_slot
- Server broadcasts party_update to all player sessions
- Client has gameSocket.reorderParty() method ready for frontend use
- @dnd-kit packages installed for Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/12-party-reordering/12-01-SUMMARY.md`
</output>
