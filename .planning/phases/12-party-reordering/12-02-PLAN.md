---
phase: 12-party-reordering
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - apps/web/src/components/game/party/SortablePartyGrid.tsx
  - apps/web/src/components/game/party/SortablePokemonCard.tsx
  - apps/web/src/components/game/party/useDragSensors.ts
  - apps/web/src/components/game/PartyPanel.tsx
autonomous: true

must_haves:
  truths:
    - "User can drag Pokemon cards to swap positions (mouse and touch)"
    - "Dragging Pokemon A to Pokemon B slot swaps their positions"
    - "Drag only activates after 300ms hold (touch) or 8px movement (mouse)"
    - "Party order persists to database after reorder"
  artifacts:
    - path: "apps/web/src/components/game/party/SortablePartyGrid.tsx"
      provides: "DndContext wrapper with sortable grid"
      min_lines: 60
    - path: "apps/web/src/components/game/party/SortablePokemonCard.tsx"
      provides: "Draggable Pokemon card wrapper"
      min_lines: 40
    - path: "apps/web/src/components/game/party/useDragSensors.ts"
      provides: "Sensor configuration hook"
      exports: ["useDragSensors"]
    - path: "apps/web/src/components/game/PartyPanel.tsx"
      provides: "Updated to use SortablePartyGrid"
      contains: "SortablePartyGrid"
  key_links:
    - from: "apps/web/src/components/game/PartyPanel.tsx"
      to: "apps/web/src/components/game/party/SortablePartyGrid.tsx"
      via: "component import"
      pattern: "import.*SortablePartyGrid"
    - from: "apps/web/src/components/game/party/SortablePartyGrid.tsx"
      to: "apps/web/src/lib/ws/gameSocket.ts"
      via: "gameSocket.reorderParty"
      pattern: "gameSocket\\.reorderParty"
---

<objective>
Implement drag-and-drop party reordering using @dnd-kit with swap behavior.

Purpose: Allow players to organize their party by dragging Pokemon cards, persisting order to database.
Output: Working drag-and-drop reordering with mouse/touch support and database persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-party-reordering/12-CONTEXT.md
@.planning/phases/12-party-reordering/12-RESEARCH.md
@.planning/phases/12-party-reordering/12-01-SUMMARY.md

# Key existing files
@apps/web/src/components/game/PartyPanel.tsx
@apps/web/src/components/game/PokemonCard.tsx
@apps/web/src/stores/gameStore.ts (setParty function)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create drag sensor configuration hook</name>
  <files>apps/web/src/components/game/party/useDragSensors.ts</files>
  <action>
Create new file at `apps/web/src/components/game/party/useDragSensors.ts`:

```typescript
'use client'

import {
  useSensor,
  useSensors,
  PointerSensor,
  TouchSensor,
  KeyboardSensor,
} from '@dnd-kit/core'
import { sortableKeyboardCoordinates } from '@dnd-kit/sortable'

/**
 * Configure drag sensors for party reordering
 * - Mouse: 8px movement threshold before drag starts
 * - Touch: 300ms hold before drag starts (prevents accidental drags)
 * - Keyboard: Arrow keys for accessibility
 */
export function useDragSensors() {
  return useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // 8px movement before drag starts (mouse)
      },
    }),
    useSensor(TouchSensor, {
      activationConstraint: {
        delay: 300,     // 300ms hold before drag starts (per CONTEXT.md)
        tolerance: 5,   // 5px movement tolerance during hold
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  )
}
```

This hook configures sensors per CONTEXT.md (300ms long-press) and RESEARCH.md patterns.
  </action>
  <verify>
File exists and TypeScript compiles: `cd apps/web && npx tsc --noEmit`
  </verify>
  <done>useDragSensors hook created with 300ms touch delay and 8px mouse threshold</done>
</task>

<task type="auto">
  <name>Task 2: Create SortablePokemonCard wrapper</name>
  <files>apps/web/src/components/game/party/SortablePokemonCard.tsx</files>
  <action>
Create new file at `apps/web/src/components/game/party/SortablePokemonCard.tsx`:

```typescript
'use client'

import { useSortable } from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'
import type { Pokemon } from '@/types/game'
import { PokemonCard } from '../PokemonCard'
import { cn } from '@/lib/ui/cn'

interface SortablePokemonCardProps {
  pokemon: Pokemon
  onRemove?: () => void
  canRemove?: boolean
  onUsePotion?: (pokemonId: string) => void
  hasPotions?: boolean
  onClick?: () => void
  disabled?: boolean
}

export function SortablePokemonCard({
  pokemon,
  onRemove,
  canRemove,
  onUsePotion,
  hasPotions,
  onClick,
  disabled = false,
}: SortablePokemonCardProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: pokemon.id,
    disabled,
  })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    // Lift effect when dragging (per CONTEXT.md)
    zIndex: isDragging ? 50 : undefined,
  }

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
      className={cn(
        'h-full touch-manipulation select-none',
        isDragging && 'opacity-50 scale-105',
        disabled && 'cursor-not-allowed opacity-70'
      )}
    >
      <PokemonCard
        pokemon={pokemon}
        showXP
        onClick={disabled ? undefined : onClick}
        canRemove={canRemove}
        onRemove={onRemove}
        onUsePotion={onUsePotion}
        hasPotions={hasPotions}
      />
    </div>
  )
}
```

Key features:
- Uses useSortable hook from @dnd-kit
- CSS.Transform for smooth animations
- touch-manipulation CSS for proper touch handling (per RESEARCH.md pitfall)
- Opacity reduction when dragging to show source position
- Disabled state for battle mode
  </action>
  <verify>
File exists and TypeScript compiles: `cd apps/web && npx tsc --noEmit`
  </verify>
  <done>SortablePokemonCard wrapper component created with proper drag styles</done>
</task>

<task type="auto">
  <name>Task 3: Create SortablePartyGrid with reorder logic</name>
  <files>apps/web/src/components/game/party/SortablePartyGrid.tsx</files>
  <action>
Create new file at `apps/web/src/components/game/party/SortablePartyGrid.tsx`:

```typescript
'use client'

import { useState, useCallback } from 'react'
import {
  DndContext,
  closestCenter,
  DragOverlay,
  type DragStartEvent,
  type DragEndEvent,
} from '@dnd-kit/core'
import {
  SortableContext,
  rectSwappingStrategy,
  arraySwap,
} from '@dnd-kit/sortable'
import type { Pokemon } from '@/types/game'
import { useGameStore } from '@/stores/gameStore'
import { gameSocket } from '@/lib/ws/gameSocket'
import { useDragSensors } from './useDragSensors'
import { SortablePokemonCard } from './SortablePokemonCard'
import { PokemonCard, EmptyPokemonSlot } from '../PokemonCard'
import { getStaggerDelayStyle } from '@/lib/ui'

interface SortablePartyGridProps {
  party: (Pokemon | null)[]
  onPokemonClick: (pokemon: Pokemon) => void
  canRemove: boolean
  onRemove: (partySlot: number) => void
  onUsePotion: (pokemonId: string) => void
  hasPotions: boolean
}

export function SortablePartyGrid({
  party,
  onPokemonClick,
  canRemove,
  onRemove,
  onUsePotion,
  hasPotions,
}: SortablePartyGridProps) {
  const sensors = useDragSensors()
  const currentEncounter = useGameStore((state) => state.currentEncounter)
  const setParty = useGameStore((state) => state.setParty)

  // Local state for active drag (NOT in Zustand - per RESEARCH.md pitfall DD-1)
  const [activeId, setActiveId] = useState<string | null>(null)
  const [previousParty, setPreviousParty] = useState<(Pokemon | null)[] | null>(null)

  // Disable drag during battle
  const isDragDisabled = !!currentEncounter

  // Get sortable item IDs (only non-null Pokemon)
  const sortableIds = party
    .filter((p): p is Pokemon => p !== null)
    .map(p => p.id)

  const handleDragStart = useCallback((event: DragStartEvent) => {
    setActiveId(event.active.id as string)
    setPreviousParty([...party])
  }, [party])

  const handleDragEnd = useCallback((event: DragEndEvent) => {
    const { active, over } = event
    setActiveId(null)

    if (!over || active.id === over.id) {
      setPreviousParty(null)
      return
    }

    // Find indices in the party array
    const oldIndex = party.findIndex(p => p?.id === active.id)
    const newIndex = party.findIndex(p => p?.id === over.id)

    if (oldIndex === -1 || newIndex === -1) {
      setPreviousParty(null)
      return
    }

    // Swap positions (per CONTEXT.md: "dragging to occupied slot: swap positions")
    const newParty = arraySwap([...party], oldIndex, newIndex)

    // Optimistic update
    setParty(newParty.filter((p): p is Pokemon => p !== null))

    // Build order array for server (array of IDs, null for empty)
    const order = newParty.map(p => p?.id ?? null)

    // Send to server
    const sent = gameSocket.reorderParty(order)

    if (!sent && previousParty) {
      // Rollback if not connected
      setParty(previousParty.filter((p): p is Pokemon => p !== null))
      // TODO: Show toast in Plan 03
    }

    setPreviousParty(null)
  }, [party, setParty, previousParty])

  const handleDragCancel = useCallback(() => {
    setActiveId(null)
    if (previousParty) {
      setParty(previousParty.filter((p): p is Pokemon => p !== null))
    }
    setPreviousParty(null)
  }, [previousParty, setParty])

  const activePokemon = activeId
    ? party.find(p => p?.id === activeId)
    : null

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      onDragCancel={handleDragCancel}
    >
      <SortableContext
        items={sortableIds}
        strategy={rectSwappingStrategy}
      >
        <div
          className="grid grid-cols-2 gap-2 auto-rows-fr"
          role="list"
          aria-label="Pokemon party"
        >
          {party.map((pokemon, index) =>
            pokemon ? (
              <div
                key={pokemon.id}
                className="animate-slide-up h-full"
                style={getStaggerDelayStyle(index)}
                role="listitem"
              >
                <SortablePokemonCard
                  pokemon={pokemon}
                  onClick={() => onPokemonClick(pokemon)}
                  canRemove={canRemove}
                  onRemove={() => onRemove(pokemon.party_slot!)}
                  onUsePotion={onUsePotion}
                  hasPotions={hasPotions}
                  disabled={isDragDisabled}
                />
              </div>
            ) : (
              <EmptyPokemonSlot key={`empty-${index}`} slot={index + 1} />
            )
          )}
        </div>
      </SortableContext>

      {/* Drag overlay - shows lifted card appearance (per CONTEXT.md) */}
      <DragOverlay dropAnimation={{ duration: 100, easing: 'ease-out' }}>
        {activePokemon ? (
          <div className="scale-105 shadow-2xl rounded-xl">
            <PokemonCard
              pokemon={activePokemon}
              showXP
            />
          </div>
        ) : null}
      </DragOverlay>
    </DndContext>
  )
}
```

Key features:
- Uses rectSwappingStrategy + arraySwap for swap behavior (not shift)
- Local state for activeId (avoids Zustand re-render cascade per RESEARCH.md DD-1)
- Optimistic update with rollback capability
- Disabled during battle (per CONTEXT.md)
- DragOverlay with lifted appearance (scale 1.05 + shadow)
- Preserves existing grid layout and animations
  </action>
  <verify>
File exists and TypeScript compiles: `cd apps/web && npx tsc --noEmit`
  </verify>
  <done>SortablePartyGrid component created with swap logic and optimistic updates</done>
</task>

<task type="auto">
  <name>Task 4: Update PartyPanel to use SortablePartyGrid</name>
  <files>apps/web/src/components/game/PartyPanel.tsx</files>
  <action>
Update PartyPanel.tsx to use the new SortablePartyGrid:

1. Add import at top:
   ```typescript
   import { SortablePartyGrid } from './party/SortablePartyGrid'
   ```

2. Replace the existing grid div (lines 88-119) with SortablePartyGrid:

   Remove this block:
   ```tsx
   {/* Party Grid - responsive columns with equal row heights */}
   <div
     className="grid grid-cols-2 gap-2 auto-rows-fr"
     role="list"
     aria-label="Pokemon party"
   >
     {party.map((pokemon, index) =>
       pokemon ? (
         <div
           key={pokemon.id}
           className="animate-slide-up h-full"
           style={getStaggerDelayStyle(index)}
           role="listitem"
         >
           <PokemonCard
             pokemon={pokemon}
             showXP
             onClick={() => setDetailPokemon(pokemon)}
             canRemove={activePartyCount > 1}
             onRemove={() => {
               if (pokemon.party_slot) {
                 gameSocket.removeFromParty(pokemon.party_slot)
               }
             }}
             onUsePotion={handleUsePotion}
             hasPotions={hasPotions}
           />
         </div>
       ) : (
         <EmptyPokemonSlot key={`empty-${index}`} slot={index + 1} />
       )
     )}
   </div>
   ```

   Replace with:
   ```tsx
   {/* Party Grid - sortable with drag-to-reorder */}
   <SortablePartyGrid
     party={party}
     onPokemonClick={setDetailPokemon}
     canRemove={activePartyCount > 1}
     onRemove={(partySlot) => gameSocket.removeFromParty(partySlot)}
     onUsePotion={handleUsePotion}
     hasPotions={hasPotions}
   />
   ```

3. Remove unused imports:
   - Remove `getStaggerDelayStyle` import if no longer used elsewhere
   - Keep `PokemonCard, EmptyPokemonSlot` import since EmptyPokemonSlot is used in SortablePartyGrid

The PartyPanel component becomes cleaner by delegating grid/drag logic to SortablePartyGrid.
  </action>
  <verify>
1. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
2. Run dev server: `cd apps/web && npm run dev`
3. Open browser, navigate to game, verify party panel renders
  </verify>
  <done>PartyPanel uses SortablePartyGrid, existing functionality preserved</done>
</task>

</tasks>

<verification>
1. All TypeScript compiles without errors
2. Party panel renders correctly in browser
3. Can drag Pokemon card on desktop (mouse)
4. Can long-press and drag on mobile/touch simulation
5. Swapping two Pokemon cards exchanges their positions
6. Party order persists after page refresh
</verification>

<success_criteria>
- Drag-and-drop works on both mouse and touch devices
- Long-press (300ms) required on touch before drag activates
- Dragging Pokemon A to Pokemon B slot swaps their positions
- Order persists to database (verify with page refresh)
- Dragging is disabled during active battle
</success_criteria>

<output>
After completion, create `.planning/phases/12-party-reordering/12-02-SUMMARY.md`
</output>
