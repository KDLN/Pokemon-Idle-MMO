---
phase: 06-guild-shop-statistics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/028_guild_shop.sql
autonomous: true

must_haves:
  truths:
    - "Guild can purchase buffs using bank currency or guild points"
    - "Active buffs persist and have expiration timestamps"
    - "Only leader or officer can purchase buffs"
    - "Guild statistics can be computed (catches, species, members, age)"
    - "Guilds can be ranked by configurable metrics"
  artifacts:
    - path: "supabase/migrations/028_guild_shop.sql"
      provides: "Buff tables, shop functions, statistics functions, leaderboard views"
      min_lines: 300
      contains: "guild_buffs"
  key_links:
    - from: "guild_buffs table"
      to: "guild_bank_currency"
      via: "purchase_guild_buff function deducts currency"
      pattern: "UPDATE guild_bank_currency"
---

<objective>
Create database schema for guild shop buffs, statistics aggregation, and leaderboard ranking.

Purpose: Provide persistent storage for time-limited guild buffs with atomic purchase operations, and efficient statistics/ranking queries for the leaderboard.

Output: Single migration file with buff tables, SECURITY DEFINER purchase functions, statistics aggregation functions, and leaderboard ranking queries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-guild-shop-statistics/06-RESEARCH.md
@supabase/migrations/026_guild_bank.sql
@supabase/migrations/027_guild_quests.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create guild_buffs table and buff purchase function</name>
  <files>supabase/migrations/028_guild_shop.sql</files>
  <action>
Create migration file with:

1. **guild_buffs table:**
```sql
CREATE TABLE guild_buffs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  guild_id UUID NOT NULL REFERENCES guilds(id) ON DELETE CASCADE,
  buff_type VARCHAR(50) NOT NULL,  -- 'xp_bonus', 'catch_rate', 'encounter_rate'
  multiplier DECIMAL(3,2) NOT NULL DEFAULT 1.10,  -- 1.10 = +10%
  started_at TIMESTAMPTZ DEFAULT NOW(),
  ends_at TIMESTAMPTZ NOT NULL,
  purchased_by UUID REFERENCES players(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(guild_id, buff_type)  -- Only one active buff per type per guild
);
```

Add index on guild_id and ends_at for efficient active buff queries.

2. **guild_buff_purchases table (history):**
```sql
CREATE TABLE guild_buff_purchases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  guild_id UUID NOT NULL REFERENCES guilds(id) ON DELETE CASCADE,
  buff_type VARCHAR(50) NOT NULL,
  duration_hours INT NOT NULL,
  cost_currency BIGINT,
  cost_guild_points INT,
  purchased_by UUID REFERENCES players(id) ON DELETE SET NULL,
  purchased_at TIMESTAMPTZ DEFAULT NOW()
);
```

3. **purchase_guild_buff() SECURITY DEFINER function:**
- Check player is in guild with leader/officer role (FOR UPDATE lock on guild_members)
- Validate buff_type is one of: 'xp_bonus', 'catch_rate', 'encounter_rate'
- Calculate cost based on buff type and duration (1000 currency per hour OR 200 guild points per hour)
- Check guild bank has sufficient funds (currency or guild points)
- Deduct currency from guild_bank_currency OR guild_points from guilds.guild_points column
- UPSERT into guild_buffs with GREATEST(ends_at, NOW()) + duration for stacking
- Cap ends_at at NOW() + 24 hours maximum
- Insert into guild_buff_purchases for history
- Log to guild_bank_logs as 'withdraw' action with buff_purchase details
- Return JSON with success, new ends_at, remaining balance

4. **get_active_guild_buffs() function:**
- Takes guild_id, returns JSON object with active buffs keyed by buff_type
- Filter WHERE ends_at > NOW()
- Return null for each buff_type if not active

5. **RLS policies:**
- Block all direct INSERT/UPDATE/DELETE on guild_buffs (force use of functions)
- Allow SELECT for guild members only

Costs per buff (1 hour duration):
- xp_bonus: 1000 currency OR 200 guild points
- catch_rate: 1000 currency OR 200 guild points
- encounter_rate: 1000 currency OR 200 guild points
  </action>
  <verify>
Migration file contains guild_buffs table, guild_buff_purchases table, purchase_guild_buff function, get_active_guild_buffs function, and RLS policies.
  </verify>
  <done>
Buff storage with atomic purchase function accepting currency or guild points, stacking up to 24h, with purchase history tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create guild statistics and leaderboard functions</name>
  <files>supabase/migrations/028_guild_shop.sql</files>
  <action>
Append to migration file:

1. **Add guild_points column to guilds table (if not exists):**
```sql
ALTER TABLE guilds ADD COLUMN IF NOT EXISTS guild_points INT DEFAULT 0;
```

2. **get_guild_statistics() function:**
```sql
CREATE OR REPLACE FUNCTION get_guild_statistics(p_guild_id UUID)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_stats JSON;
BEGIN
  SELECT json_build_object(
    'total_catches', (
      SELECT COALESCE(SUM(pe.catch_count), 0)
      FROM pokedex_entries pe
      JOIN players p ON p.id = pe.player_id
      WHERE p.guild_id = p_guild_id
    ),
    'unique_species', (
      SELECT COUNT(DISTINCT pe.species_id)
      FROM pokedex_entries pe
      JOIN players p ON p.id = pe.player_id
      WHERE p.guild_id = p_guild_id AND pe.caught = true
    ),
    'member_count', g.member_count,
    'avg_level', (
      SELECT COALESCE(ROUND(AVG(poke.level)::numeric, 1), 0)
      FROM pokemon poke
      JOIN players pl ON pl.id = poke.owner_id
      WHERE pl.guild_id = p_guild_id
    ),
    'days_active', EXTRACT(DAY FROM NOW() - g.created_at)::INT,
    'created_at', g.created_at,
    'guild_points', g.guild_points
  ) INTO v_stats
  FROM guilds g
  WHERE g.id = p_guild_id;

  RETURN v_stats;
END;
$$;
```

3. **get_guild_leaderboard() function:**
```sql
CREATE OR REPLACE FUNCTION get_guild_leaderboard(
  p_metric TEXT,  -- 'catches', 'pokedex', 'members'
  p_limit INT DEFAULT 50
)
RETURNS JSON
LANGUAGE plpgsql
AS $$
BEGIN
  IF p_metric = 'members' THEN
    RETURN (
      SELECT json_agg(row_to_json(r)) FROM (
        SELECT
          ROW_NUMBER() OVER (ORDER BY member_count DESC, created_at ASC) as rank,
          id, name, tag, member_count as value,
          (SELECT username FROM players WHERE id = g.leader_id) as leader_name
        FROM guilds g
        ORDER BY member_count DESC, created_at ASC
        LIMIT p_limit
      ) r
    );
  ELSIF p_metric = 'catches' THEN
    RETURN (
      SELECT json_agg(row_to_json(r)) FROM (
        SELECT
          ROW_NUMBER() OVER (ORDER BY total_catches DESC, g.created_at ASC) as rank,
          g.id, g.name, g.tag, total_catches as value,
          (SELECT username FROM players WHERE id = g.leader_id) as leader_name
        FROM guilds g
        LEFT JOIN (
          SELECT p.guild_id, COALESCE(SUM(pe.catch_count), 0) as total_catches
          FROM players p
          JOIN pokedex_entries pe ON pe.player_id = p.id
          GROUP BY p.guild_id
        ) stats ON stats.guild_id = g.id
        ORDER BY total_catches DESC, g.created_at ASC
        LIMIT p_limit
      ) r
    );
  ELSIF p_metric = 'pokedex' THEN
    RETURN (
      SELECT json_agg(row_to_json(r)) FROM (
        SELECT
          ROW_NUMBER() OVER (ORDER BY unique_species DESC, g.created_at ASC) as rank,
          g.id, g.name, g.tag, unique_species as value,
          (SELECT username FROM players WHERE id = g.leader_id) as leader_name
        FROM guilds g
        LEFT JOIN (
          SELECT p.guild_id, COUNT(DISTINCT pe.species_id) as unique_species
          FROM players p
          JOIN pokedex_entries pe ON pe.player_id = p.id
          WHERE pe.caught = true
          GROUP BY p.guild_id
        ) stats ON stats.guild_id = g.id
        ORDER BY unique_species DESC, g.created_at ASC
        LIMIT p_limit
      ) r
    );
  ELSE
    RETURN '[]'::json;
  END IF;
END;
$$;
```

4. **get_player_guild_rank() function:**
- Takes player_id and metric, returns their guild's rank (or null if no guild)
  </action>
  <verify>
Migration file contains get_guild_statistics function, get_guild_leaderboard function with 3 metrics, and get_player_guild_rank function.
  </verify>
  <done>
Statistics aggregation returns total catches, unique species, member count, avg level, days active. Leaderboard ranks top 50 guilds by catches, pokedex, or members.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add indexes and cleanup functions</name>
  <files>supabase/migrations/028_guild_shop.sql</files>
  <action>
Append to migration file:

1. **Performance indexes:**
```sql
-- Fast active buff lookups
CREATE INDEX idx_guild_buffs_guild_ends ON guild_buffs(guild_id, ends_at);

-- Fast leaderboard queries
CREATE INDEX idx_players_guild_id ON players(guild_id) WHERE guild_id IS NOT NULL;
CREATE INDEX idx_pokedex_player_caught ON pokedex_entries(player_id) WHERE caught = true;
```

2. **cleanup_expired_buffs() function (called opportunistically):**
```sql
CREATE OR REPLACE FUNCTION cleanup_expired_buffs()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  DELETE FROM guild_buffs WHERE ends_at < NOW();
END;
$$;
```

3. **Trigger to cleanup expired buffs when purchasing:**
Add cleanup call at start of purchase_guild_buff() function (opportunistic cleanup pattern).

4. **Grant permissions:**
```sql
GRANT SELECT ON guild_buffs TO authenticated;
GRANT SELECT ON guild_buff_purchases TO authenticated;
GRANT EXECUTE ON FUNCTION purchase_guild_buff TO authenticated;
GRANT EXECUTE ON FUNCTION get_active_guild_buffs TO authenticated;
GRANT EXECUTE ON FUNCTION get_guild_statistics TO authenticated;
GRANT EXECUTE ON FUNCTION get_guild_leaderboard TO authenticated;
```
  </action>
  <verify>
Run: `grep -c "CREATE INDEX" supabase/migrations/028_guild_shop.sql` shows at least 3 indexes.
Run: `grep -c "GRANT" supabase/migrations/028_guild_shop.sql` shows permission grants.
  </verify>
  <done>
Indexes optimize buff and leaderboard queries. Cleanup removes expired buffs opportunistically. All functions have proper permissions.
  </done>
</task>

</tasks>

<verification>
1. Migration file exists with complete schema
2. Contains guild_buffs and guild_buff_purchases tables
3. Contains purchase_guild_buff with role check, currency/points deduction, stacking, 24h cap
4. Contains get_active_guild_buffs for tick processing
5. Contains get_guild_statistics with all required metrics
6. Contains get_guild_leaderboard with catches/pokedex/members metrics
7. Has RLS policies and indexes
</verification>

<success_criteria>
- Migration file compiles without syntax errors
- All 6 functions created (purchase, get_active, get_statistics, get_leaderboard, get_rank, cleanup)
- Buff purchase deducts from bank currency OR guild points
- Buff stacking capped at 24 hours
- Statistics aggregation computes all required metrics
- Leaderboard returns top 50 ranked guilds
</success_criteria>

<output>
After completion, create `.planning/phases/06-guild-shop-statistics/06-01-SUMMARY.md`
</output>
