---
phase: 06-guild-shop-statistics
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - apps/game-server/src/db.ts
  - apps/game-server/src/hub.ts
  - apps/game-server/src/game.ts
  - apps/game-server/src/types.ts
autonomous: true

must_haves:
  truths:
    - "Guild members can purchase buffs via WebSocket"
    - "Active buff effects apply during tick processing"
    - "+10% XP bonus applies to XP earned from battles"
    - "+10% catch rate bonus applies to catch attempts"
    - "+10% encounter rate bonus applies to encounter rolls"
    - "Guild statistics can be fetched via WebSocket"
    - "Guild leaderboard can be fetched with configurable metric"
  artifacts:
    - path: "apps/game-server/src/db.ts"
      provides: "purchaseGuildBuff, getActiveGuildBuffs, getGuildStatistics, getGuildLeaderboard functions"
      exports: ["purchaseGuildBuff", "getActiveGuildBuffs", "getGuildStatistics", "getGuildLeaderboard"]
    - path: "apps/game-server/src/hub.ts"
      provides: "WebSocket handlers for shop and statistics, buff cache, buff application in tick"
      contains: "purchase_guild_buff"
    - path: "apps/game-server/src/game.ts"
      provides: "Buff-aware processTick and attemptCatch functions"
      contains: "guildBuffs"
  key_links:
    - from: "apps/game-server/src/hub.ts"
      to: "apps/game-server/src/db.ts"
      via: "purchaseGuildBuff, getActiveGuildBuffs RPC calls"
      pattern: "purchaseGuildBuff\\("
    - from: "apps/game-server/src/game.ts"
      to: "ActiveGuildBuffs type"
      via: "processTick accepts optional buffs parameter"
      pattern: "guildBuffs.*ActiveGuildBuffs"
---

<objective>
Implement game server handlers for guild shop buff purchases, statistics, and leaderboard, plus integrate buff effects into tick processing.

Purpose: Enable players to purchase guild buffs, view statistics, access leaderboards, and have buff effects actually apply during gameplay.

Output: Database wrapper functions in db.ts, WebSocket handlers in hub.ts, buff-aware game logic in game.ts, updated type exports.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-guild-shop-statistics/06-RESEARCH.md
@.planning/phases/06-guild-shop-statistics/06-01-SUMMARY.md
@.planning/phases/06-guild-shop-statistics/06-02-SUMMARY.md
@apps/game-server/src/hub.ts
@apps/game-server/src/db.ts
@apps/game-server/src/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add database wrapper functions and type exports</name>
  <files>apps/game-server/src/db.ts, apps/game-server/src/types.ts</files>
  <action>
1. **In types.ts**, add imports/re-exports for new types:
```typescript
// Add to imports from @pokemon-idle/shared
import type {
  // ... existing imports ...
  GuildBuffType,
  GuildBuff,
  ActiveGuildBuffs,
  GuildStatistics,
  LeaderboardMetric,
  GuildLeaderboardEntry,
  GuildRankInfo,
  PurchaseGuildBuffPayload,
  GetGuildLeaderboardPayload,
  GuildActiveBuffsPayload,
  GuildBuffPurchasedPayload,
  GuildStatisticsPayload,
  GuildLeaderboardPayload,
  GuildShopErrorPayload
} from '@pokemon-idle/shared'

// Re-export
export type {
  GuildBuffType,
  GuildBuff,
  ActiveGuildBuffs,
  GuildStatistics,
  LeaderboardMetric,
  GuildLeaderboardEntry,
  GuildRankInfo,
  PurchaseGuildBuffPayload,
  GetGuildLeaderboardPayload,
  GuildActiveBuffsPayload,
  GuildBuffPurchasedPayload,
  GuildStatisticsPayload,
  GuildLeaderboardPayload,
  GuildShopErrorPayload
}
```

2. **In db.ts**, add wrapper functions after guild quest functions:

```typescript
// ================================
// Guild Shop & Statistics
// ================================

export async function purchaseGuildBuff(
  playerId: string,
  guildId: string,
  buffType: string,
  durationHours: number,
  useGuildPoints: boolean
): Promise<{ success: boolean; error?: string; buff?: GuildBuff; remaining_currency?: number; remaining_guild_points?: number }> {
  const { data, error } = await getSupabase().rpc('purchase_guild_buff', {
    p_player_id: playerId,
    p_guild_id: guildId,
    p_buff_type: buffType,
    p_duration_hours: durationHours,
    p_use_guild_points: useGuildPoints
  })

  if (error) {
    console.error('[DB purchaseGuildBuff] Error:', error)
    return { success: false, error: error.message }
  }

  return data
}

export async function getActiveGuildBuffs(guildId: string): Promise<ActiveGuildBuffs | null> {
  const { data, error } = await getSupabase().rpc('get_active_guild_buffs', {
    p_guild_id: guildId
  })

  if (error) {
    console.error('[DB getActiveGuildBuffs] Error:', error)
    return null
  }

  return data
}

export async function getGuildStatistics(guildId: string): Promise<GuildStatistics | null> {
  const { data, error } = await getSupabase().rpc('get_guild_statistics', {
    p_guild_id: guildId
  })

  if (error) {
    console.error('[DB getGuildStatistics] Error:', error)
    return null
  }

  return data
}

export async function getGuildLeaderboard(
  metric: string,
  limit: number = 50
): Promise<GuildLeaderboardEntry[]> {
  const { data, error } = await getSupabase().rpc('get_guild_leaderboard', {
    p_metric: metric,
    p_limit: Math.min(limit, 50)
  })

  if (error) {
    console.error('[DB getGuildLeaderboard] Error:', error)
    return []
  }

  return data || []
}

export async function getPlayerGuildRank(
  playerId: string,
  metric: string
): Promise<GuildRankInfo | null> {
  const { data, error } = await getSupabase().rpc('get_player_guild_rank', {
    p_player_id: playerId,
    p_metric: metric
  })

  if (error) {
    console.error('[DB getPlayerGuildRank] Error:', error)
    return null
  }

  return data
}
```
  </action>
  <verify>
Run: `grep -c "purchaseGuildBuff\|getActiveGuildBuffs\|getGuildStatistics\|getGuildLeaderboard" apps/game-server/src/db.ts` shows 4+ matches.
  </verify>
  <done>
Database wrappers added: purchaseGuildBuff, getActiveGuildBuffs, getGuildStatistics, getGuildLeaderboard, getPlayerGuildRank. Type exports updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify game.ts to accept guild buffs in tick processing</name>
  <files>apps/game-server/src/game.ts</files>
  <action>
1. **Import ActiveGuildBuffs type at top:**
```typescript
import type { ActiveGuildBuffs } from './types.js'
```

2. **Modify processTick signature to accept optional buffs:**
```typescript
export function processTick(
  session: PlayerSession,
  speciesMap: Map<number, PokemonSpecies>,
  guildBuffs?: ActiveGuildBuffs | null
): TickResult {
```

3. **Apply encounter rate buff to rollEncounter call (~line 898):**
Before:
```typescript
if (!rollEncounter(session.zone.base_encounter_rate)) {
```
After:
```typescript
const encounterRate = guildBuffs?.encounter_rate
  ? session.zone.base_encounter_rate * guildBuffs.encounter_rate.multiplier
  : session.zone.base_encounter_rate
if (!rollEncounter(encounterRate)) {
```

4. **Modify attemptCatch to accept optional catch rate buff:**
```typescript
export function attemptCatch(
  wild: WildPokemon,
  ballCount: number,
  ballType: BallType,
  catchRateMultiplier: number = 1.0
): { result: CatchResult; newBallCount: number } {
```

Apply multiplier after base calculation:
```typescript
let catchChance = (baseCatchRate * ballModifier) / 255.0
// Apply catch rate buff
catchChance *= catchRateMultiplier
// Level modifier
const levelMod = Math.max(0.5, 1.0 - wild.level * 0.02)
catchChance *= levelMod
```

5. **Modify processEncounter to accept catch rate multiplier:**
```typescript
export function processEncounter(
  party: (Pokemon | null)[],
  zone: Zone,
  encounterTable: EncounterTableEntry[],
  pokeballs: number,
  great_balls: number,
  speciesMap: Map<number, PokemonSpecies>,
  catchRateMultiplier: number = 1.0
): { encounter: EncounterEvent | null; newPokeballs: number; newGreatBalls: number }
```

Pass multiplier to attemptCatch calls:
```typescript
const { result, newBallCount } = attemptCatch(wild, great_balls, 'great_ball', catchRateMultiplier)
// and
const { result, newBallCount } = attemptCatch(wild, pokeballs, 'pokeball', catchRateMultiplier)
```

6. **Pass catch rate multiplier through processTick:**
In processTick, when calling processEncounter:
```typescript
const catchRateMultiplier = guildBuffs?.catch_rate?.multiplier || 1.0
const { encounter, newPokeballs, newGreatBalls } = processEncounter(
  session.party,
  session.zone,
  session.encounterTable,
  session.pokeballs,
  session.great_balls,
  speciesMap,
  catchRateMultiplier
)
```

7. **Apply XP buff to distributeXP result:**
In processTick where xp_gained is assigned (~line 927):
```typescript
const xpMultiplier = guildBuffs?.xp_bonus?.multiplier || 1.0
result.xp_gained = distributeXP(session.party, encounter.wild_pokemon, encounter.battle_sequence)

// Apply XP buff to all gained XP
if (xpMultiplier > 1.0 && result.xp_gained) {
  for (const pokemonId of Object.keys(result.xp_gained)) {
    result.xp_gained[pokemonId] = Math.floor(result.xp_gained[pokemonId] * xpMultiplier)
  }
}
```
  </action>
  <verify>
Run: `grep -c "guildBuffs" apps/game-server/src/game.ts` shows at least 5 matches.
Run: `grep "catchRateMultiplier" apps/game-server/src/game.ts` shows multiplier being passed and used.
  </verify>
  <done>
Game logic updated: processTick accepts guildBuffs parameter, encounter rate buff applied to rollEncounter, catch rate buff applied to attemptCatch, XP buff applied to distributeXP result.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add WebSocket handlers and buff cache in hub.ts</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
1. **Add imports for new db functions and types:**
```typescript
import {
  // ... existing imports ...
  purchaseGuildBuff,
  getActiveGuildBuffs,
  getGuildStatistics,
  getGuildLeaderboard,
  getPlayerGuildRank
} from './db.js'

import type {
  // ... existing imports ...
  ActiveGuildBuffs,
  PurchaseGuildBuffPayload,
  GetGuildLeaderboardPayload
} from './types.js'
```

2. **Add buff cache as class property (in Hub class):**
```typescript
// Guild buff cache with 5-second TTL
private guildBuffCache: Map<string, { buffs: ActiveGuildBuffs | null; expiresAt: number }> = new Map()

private async getGuildBuffsCached(guildId: string): Promise<ActiveGuildBuffs | null> {
  const cached = this.guildBuffCache.get(guildId)
  if (cached && cached.expiresAt > Date.now()) {
    return cached.buffs
  }

  const buffs = await getActiveGuildBuffs(guildId)
  this.guildBuffCache.set(guildId, {
    buffs,
    expiresAt: Date.now() + 5000  // 5 second TTL
  })
  return buffs
}

private invalidateGuildBuffCache(guildId: string): void {
  this.guildBuffCache.delete(guildId)
}
```

3. **Modify processTicks to fetch and pass guild buffs:**
In processTicks method, before calling processTick:
```typescript
// Fetch guild buffs if player is in a guild
const guildBuffs = client.session.guild?.id
  ? await this.getGuildBuffsCached(client.session.guild.id)
  : null

const result = processTick(client.session, this.speciesMap, guildBuffs)
```

4. **Add shop/stats handlers to switch statement:**
```typescript
case 'purchase_guild_buff':
  this.handlePurchaseGuildBuff(client, message.payload as PurchaseGuildBuffPayload)
  break

case 'get_active_buffs':
  this.handleGetActiveBuffs(client)
  break

case 'get_guild_statistics':
  this.handleGetGuildStatistics(client)
  break

case 'get_guild_leaderboard':
  this.handleGetGuildLeaderboard(client, message.payload as GetGuildLeaderboardPayload)
  break
```

5. **Add handler implementations:**
```typescript
private async handlePurchaseGuildBuff(client: Client, payload: PurchaseGuildBuffPayload) {
  if (!client.session?.guild) {
    this.sendError(client, 'You must be in a guild')
    return
  }

  const { buff_type, duration_hours, use_guild_points = false } = payload

  // Validate buff type
  const validBuffs = ['xp_bonus', 'catch_rate', 'encounter_rate']
  if (!validBuffs.includes(buff_type)) {
    this.sendError(client, 'Invalid buff type')
    return
  }

  // Validate duration
  if (duration_hours < 1 || duration_hours > 24) {
    this.sendError(client, 'Duration must be between 1 and 24 hours')
    return
  }

  const result = await purchaseGuildBuff(
    client.session.player.id,
    client.session.guild.id,
    buff_type,
    duration_hours,
    use_guild_points
  )

  if (!result.success) {
    this.sendError(client, result.error || 'Failed to purchase buff')
    return
  }

  // Invalidate buff cache
  this.invalidateGuildBuffCache(client.session.guild.id)

  // Broadcast to guild
  this.broadcastToGuild(client.session.guild.id, 'guild_buff_purchased', {
    buff: result.buff,
    remaining_currency: result.remaining_currency,
    remaining_guild_points: result.remaining_guild_points,
    purchased_by: client.session.player.id,
    purchased_by_username: client.session.player.username
  })

  // Send system message to guild chat
  const buffName = buff_type.replace('_', ' ')
  const message = await saveGuildMessage(
    client.session.guild.id,
    null,
    'System',
    'leader',
    `${client.session.player.username} activated ${buffName} buff for ${duration_hours} hour(s)!`
  )
  if (message) {
    this.broadcastToGuild(client.session.guild.id, 'guild_chat_message', { message })
  }
}

private async handleGetActiveBuffs(client: Client) {
  if (!client.session?.guild) {
    this.sendError(client, 'You must be in a guild')
    return
  }

  const buffs = await getActiveGuildBuffs(client.session.guild.id)

  this.send(client, 'guild_active_buffs', { buffs })
}

private async handleGetGuildStatistics(client: Client) {
  if (!client.session?.guild) {
    this.sendError(client, 'You must be in a guild')
    return
  }

  const statistics = await getGuildStatistics(client.session.guild.id)

  this.send(client, 'guild_statistics', { statistics })
}

private async handleGetGuildLeaderboard(client: Client, payload: GetGuildLeaderboardPayload) {
  const { metric, limit = 50 } = payload

  // Validate metric
  const validMetrics = ['catches', 'pokedex', 'members']
  if (!validMetrics.includes(metric)) {
    this.sendError(client, 'Invalid leaderboard metric')
    return
  }

  const entries = await getGuildLeaderboard(metric, limit)

  // Get player's guild rank if they're in a guild
  let myGuildRank = null
  if (client.session?.guild) {
    myGuildRank = await getPlayerGuildRank(client.session.player.id, metric)
  }

  this.send(client, 'guild_leaderboard', {
    metric,
    entries,
    my_guild_rank: myGuildRank
  })
}
```
  </action>
  <verify>
Run: `grep -c "purchase_guild_buff\|get_active_buffs\|get_guild_statistics\|get_guild_leaderboard" apps/game-server/src/hub.ts` shows at least 4 case statements.
Run: `grep "getGuildBuffsCached" apps/game-server/src/hub.ts` shows buff cache being used in processTicks.
  </verify>
  <done>
WebSocket handlers added: purchase_guild_buff, get_active_buffs, get_guild_statistics, get_guild_leaderboard. Buff cache with 5s TTL. processTicks fetches and passes guild buffs. Broadcasts on buff purchase. Guild chat system message on purchase.
  </done>
</task>

</tasks>

<verification>
1. db.ts contains all 5 new database wrapper functions
2. types.ts re-exports all new types from shared package
3. game.ts processTick accepts guildBuffs parameter
4. game.ts applies encounter rate buff to rollEncounter
5. game.ts applies catch rate buff to attemptCatch
6. game.ts applies XP buff to distributeXP result
7. hub.ts has buff cache with 5s TTL
8. hub.ts processTicks fetches and passes guild buffs
9. hub.ts has 4 new WebSocket handlers
10. TypeScript compiles without errors: `cd apps/game-server && npm run build`
</verification>

<success_criteria>
- Buff purchase deducts currency/points and creates/extends buff
- Active buffs fetched with caching in tick loop
- +10% XP bonus applies to XP earned
- +10% catch rate applies to catch attempts
- +10% encounter rate applies to encounter rolls
- Statistics endpoint returns all metrics
- Leaderboard returns top 50 with player's guild rank
- Guild chat announces buff purchases
</success_criteria>

<output>
After completion, create `.planning/phases/06-guild-shop-statistics/06-03-SUMMARY.md`
</output>
