---
phase: 02-guild-invites
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01
  - 02-02
files_modified:
  - apps/game-server/src/db.ts
  - apps/game-server/src/hub.ts
  - apps/game-server/src/types.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket handlers exist for send, accept, decline, cancel invite"
    - "Handlers integrate with isPlayerBlocked() check"
    - "Real-time notifications sent via getClientByPlayerId()"
    - "Session.guild updated after accepting invite"
    - "Guild members notified when new member joins via invite"
  artifacts:
    - path: "apps/game-server/src/db.ts"
      provides: "Database functions for invite operations"
      exports: ["sendGuildInvite", "acceptGuildInvite", "declineGuildInvite", "getIncomingGuildInvites"]
    - path: "apps/game-server/src/hub.ts"
      provides: "WebSocket handlers for invite operations"
      contains: "handleSendGuildInvite"
  key_links:
    - from: "handleSendGuildInvite"
      to: "sendGuildInvite (db.ts)"
      via: "RPC call"
      pattern: "sendGuildInvite\\("
    - from: "handleSendGuildInvite"
      to: "isPlayerBlocked"
      via: "block check before send"
      pattern: "isPlayerBlocked\\("
    - from: "handleAcceptGuildInvite"
      to: "client.session.guild"
      via: "session update after accept"
      pattern: "session\\.guild.*="
---

# Plan 03: Game Server Handlers for Guild Invites

## Objective

Implement WebSocket handlers and database functions for the guild invite system in the game server, enabling real-time invite sending, accepting, declining, and notifications.

Purpose: The game server mediates all invite operations, validates permissions, and pushes real-time notifications to online players.

Output: Updated db.ts with invite database functions and hub.ts with WebSocket handlers for invite operations.

## Context

**Existing patterns to follow:**
- `db.ts` - Friend request functions (sendFriendRequest, acceptFriendRequest, getIncomingFriendRequests)
- `hub.ts` - Friend handlers (handleSendFriendRequest pattern with block check and notification)
- `hub.ts` - Guild handlers (handleJoinGuild pattern with session update and broadcastToGuild)

**Research findings (from 02-RESEARCH.md):**
- Use `isPlayerBlocked()` before sending invites
- Use `getClientByPlayerId()` for real-time notifications
- Update `client.session.guild` after accepting invite (like handleJoinGuild)
- Fire-and-forget async handlers (no await in switch)

**Dependencies:**
- 02-01 (database migration) - RPC functions exist
- 02-02 (shared types) - Type definitions exist

**Requirements covered:**
- INVITE-01: Leader/Officer can send invite to any player not in a guild
- INVITE-02: Player receives invite notification
- INVITE-03: Player can accept or decline invite

## Tasks

<task type="auto">
  <name>Task 1: Add database functions for invites in db.ts</name>
  <files>apps/game-server/src/db.ts</files>
  <action>
Add the following functions to the end of `apps/game-server/src/db.ts` (before the closing of the file), in the GUILD QUERIES section or create a new GUILD INVITE QUERIES section:

```typescript
// ============================================
// GUILD INVITE QUERIES
// ============================================

/**
 * Send a guild invite (leader/officer only)
 * The database function handles:
 * - Validating actor is leader/officer
 * - Checking guild is not closed or full
 * - Validating target player exists and is not in a guild
 * - Checking for existing pending invite
 * - Creating the invite record
 */
export async function sendGuildInvite(
  actorId: string,
  targetPlayerId: string
): Promise<{ success: boolean; invite_id?: string; guild_name?: string; error?: string }> {
  const { data, error } = await supabase.rpc('send_guild_invite', {
    p_actor_id: actorId,
    p_target_player_id: targetPlayerId
  })

  if (error) {
    console.error('Error sending guild invite:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; invite_id?: string; guild_name?: string; error?: string }
}

/**
 * Accept a guild invite (joins guild as member)
 * The database function handles:
 * - Validating invite exists and belongs to player
 * - Checking invite not expired
 * - Checking player not already in a guild
 * - Checking 24hr cooldown from leaving previous guild
 * - Checking guild not full
 * - Deleting invite and adding member
 */
export async function acceptGuildInvite(
  playerId: string,
  inviteId: string
): Promise<{ success: boolean; guild_id?: string; guild_name?: string; error?: string }> {
  const { data, error } = await supabase.rpc('accept_guild_invite', {
    p_player_id: playerId,
    p_invite_id: inviteId
  })

  if (error) {
    console.error('Error accepting guild invite:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; guild_id?: string; guild_name?: string; error?: string }
}

/**
 * Decline a guild invite
 * The database function handles:
 * - Validating invite exists and belongs to player
 * - Deleting the invite
 */
export async function declineGuildInvite(
  playerId: string,
  inviteId: string
): Promise<{ success: boolean; error?: string }> {
  const { data, error } = await supabase.rpc('decline_guild_invite', {
    p_player_id: playerId,
    p_invite_id: inviteId
  })

  if (error) {
    console.error('Error declining guild invite:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; error?: string }
}

/**
 * Cancel a guild invite (leader/officer only)
 * The database function handles:
 * - Validating actor is leader/officer in the guild
 * - Validating invite exists and belongs to actor's guild
 * - Deleting the invite
 */
export async function cancelGuildInvite(
  actorId: string,
  inviteId: string
): Promise<{ success: boolean; error?: string }> {
  const { data, error } = await supabase.rpc('cancel_guild_invite', {
    p_actor_id: actorId,
    p_invite_id: inviteId
  })

  if (error) {
    console.error('Error cancelling guild invite:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; error?: string }
}

/**
 * Get incoming guild invites for a player (non-expired only)
 * Returns invites with guild info and inviter username
 */
export async function getIncomingGuildInvites(playerId: string): Promise<GuildInvite[]> {
  const { data, error } = await supabase
    .from('guild_invites')
    .select(\`
      id,
      guild_id,
      invited_by,
      created_at,
      expires_at,
      guilds!inner (
        name,
        tag,
        member_count,
        max_members
      ),
      inviter:players!guild_invites_invited_by_fkey(username)
    \`)
    .eq('player_id', playerId)
    .gt('expires_at', new Date().toISOString())
    .order('created_at', { ascending: false })

  if (error) {
    console.error('Failed to get guild invites:', error)
    return []
  }

  // Transform to flatten joins
  return (data || []).map(row => {
    // Handle both object and array forms from Supabase join
    const guildData = Array.isArray(row.guilds) ? row.guilds[0] : row.guilds
    return {
      id: row.id,
      guild_id: row.guild_id,
      guild_name: guildData?.name || 'Unknown',
      guild_tag: guildData?.tag || '???',
      member_count: guildData?.member_count || 0,
      max_members: guildData?.max_members || 50,
      invited_by: row.invited_by,
      invited_by_username: extractUsernameFromJoin(row.inviter),
      created_at: row.created_at,
      expires_at: row.expires_at
    }
  })
}

/**
 * Get outgoing guild invites for a guild (leader/officer viewing)
 * Returns invites with player username
 */
export async function getOutgoingGuildInvites(guildId: string): Promise<GuildOutgoingInvite[]> {
  const { data, error } = await supabase
    .from('guild_invites')
    .select(\`
      id,
      player_id,
      invited_by,
      created_at,
      expires_at,
      target:players!guild_invites_player_id_fkey(username),
      inviter:players!guild_invites_invited_by_fkey(username)
    \`)
    .eq('guild_id', guildId)
    .gt('expires_at', new Date().toISOString())
    .order('created_at', { ascending: false })

  if (error) {
    console.error('Failed to get outgoing guild invites:', error)
    return []
  }

  return (data || []).map(row => ({
    id: row.id,
    player_id: row.player_id,
    player_username: extractUsernameFromJoin(row.target),
    invited_by: row.invited_by,
    invited_by_username: extractUsernameFromJoin(row.inviter),
    created_at: row.created_at,
    expires_at: row.expires_at
  }))
}
```

Also add the import for GuildInvite and GuildOutgoingInvite at the top of db.ts:
```typescript
import type { ..., GuildInvite, GuildOutgoingInvite } from './types.js'
```
  </action>
  <verify>Check that function signatures match database RPC functions. Verify import paths are correct.</verify>
  <done>Database functions added for send, accept, decline, cancel invites and fetching pending invites.</done>
</task>

<task type="auto">
  <name>Task 2: Add type imports and message type handling in types.ts</name>
  <files>apps/game-server/src/types.ts</files>
  <action>
The game-server re-exports types from @pokemon-idle/shared. Verify that the shared package exports are available.

Check `apps/game-server/src/types.ts` - it should re-export from shared:
```typescript
export * from '@pokemon-idle/shared'
```

If the invite types are properly exported from shared (Plan 02), they'll automatically be available in game-server via this re-export.

No changes needed to types.ts if it already re-exports from shared.
  </action>
  <verify>Verify that GuildInvite, SendGuildInvitePayload, etc. are accessible via `import { GuildInvite } from './types.js'`</verify>
  <done>Type imports verified - invite types accessible from types.ts via shared package re-export.</done>
</task>

<task type="auto">
  <name>Task 3: Add WebSocket handlers for guild invites in hub.ts</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
1. **Add imports at top of hub.ts:**

Find the import block from './types.js' and add the new payload types:
```typescript
import type {
  // ... existing imports ...
  SendGuildInvitePayload,
  AcceptGuildInvitePayload,
  DeclineGuildInvitePayload,
  CancelGuildInvitePayload,
  GuildInvite,
  GuildOutgoingInvite
} from './types.js'
```

Find the import block from './db.js' and add the new functions:
```typescript
import {
  // ... existing imports ...
  sendGuildInvite,
  acceptGuildInvite,
  declineGuildInvite,
  cancelGuildInvite,
  getIncomingGuildInvites,
  getOutgoingGuildInvites
} from './db.js'
```

2. **Add message handlers in the switch statement:**

Find the guild handlers section (after `case 'disband_guild':`) and add:
```typescript
        // Guild invite handlers
        case 'guild_invite_send':
          this.handleSendGuildInvite(client, msg.payload as SendGuildInvitePayload)
          break
        case 'guild_invite_accept':
          this.handleAcceptGuildInvite(client, msg.payload as AcceptGuildInvitePayload)
          break
        case 'guild_invite_decline':
          this.handleDeclineGuildInvite(client, msg.payload as DeclineGuildInvitePayload)
          break
        case 'guild_invite_cancel':
          this.handleCancelGuildInvite(client, msg.payload as CancelGuildInvitePayload)
          break
        case 'get_guild_invites':
          this.handleGetGuildInvites(client)
          break
        case 'get_guild_outgoing_invites':
          this.handleGetOutgoingGuildInvites(client)
          break
```

3. **Add handler methods after the existing guild handlers section:**

```typescript
  // ============================================
  // GUILD INVITE HANDLERS
  // ============================================

  private async handleSendGuildInvite(client: Client, payload: SendGuildInvitePayload) {
    if (!client.session) return

    const targetPlayerId = payload?.player_id
    if (!targetPlayerId || typeof targetPlayerId !== 'string') {
      this.sendError(client, 'Player ID is required')
      return
    }

    // Check actor is in a guild and has invite permission
    if (!client.session.guild) {
      this.sendError(client, 'You are not in a guild')
      return
    }

    if (!['leader', 'officer'].includes(client.session.guild.role)) {
      this.sendError(client, 'Only leaders and officers can send invites')
      return
    }

    // Check if blocked (reuse existing pattern from friend requests)
    const blocked = await isPlayerBlocked(client.session.player.id, targetPlayerId)
    if (blocked) {
      this.sendError(client, 'Cannot send invite to this player')
      return
    }

    // Get target player info for notification
    const targetPlayer = await getPlayerByUsername('') // We need player by ID
    // Actually, we need a different approach - get username from the invite result or separate query

    const result = await sendGuildInvite(client.session.player.id, targetPlayerId)

    if (!result.success) {
      this.send(client, 'guild_invite_error', { error: result.error })
      return
    }

    // Get target player username for notification
    const { data: targetData } = await getSupabase()
      .from('players')
      .select('username')
      .eq('id', targetPlayerId)
      .single()

    const targetUsername = targetData?.username || 'Unknown'

    // Notify sender
    this.send(client, 'guild_invite_sent', {
      success: true,
      player_id: targetPlayerId,
      player_username: targetUsername
    })

    // Notify target if online
    const targetClient = this.getClientByPlayerId(targetPlayerId)
    if (targetClient) {
      this.send(targetClient, 'guild_invite_received', {
        invite_id: result.invite_id,
        guild_id: client.session.guild.id,
        guild_name: client.session.guild.name,
        guild_tag: client.session.guild.tag,
        member_count: 0, // Will be accurate on fetch
        max_members: 50,
        invited_by_id: client.session.player.id,
        invited_by_username: client.session.player.username,
        created_at: new Date().toISOString(),
        expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
      })
    }
  }

  private async handleAcceptGuildInvite(client: Client, payload: AcceptGuildInvitePayload) {
    if (!client.session) return

    const inviteId = payload?.invite_id
    if (!inviteId || typeof inviteId !== 'string') {
      this.sendError(client, 'Invite ID is required')
      return
    }

    // Check not already in a guild
    if (client.session.guild) {
      this.sendError(client, 'Already in a guild')
      return
    }

    const result = await acceptGuildInvite(client.session.player.id, inviteId)

    if (!result.success) {
      this.send(client, 'guild_invite_error', { error: result.error })
      return
    }

    // Load guild data for session update
    const guild = await getGuildById(result.guild_id!)
    if (!guild) {
      this.sendError(client, 'Failed to load guild')
      return
    }

    // Update session (same pattern as handleJoinGuild)
    client.session.guild = {
      id: guild.id,
      name: guild.name,
      tag: guild.tag,
      role: 'member'
    }

    // Send guild data to the new member
    const members = await getGuildMembers(guild.id)
    this.send(client, 'guild_data', {
      guild,
      members: members.map(m => ({
        ...m,
        is_online: this.isPlayerOnline(m.player_id)
      })),
      my_role: 'member'
    })

    // Notify sender of acceptance
    this.send(client, 'guild_invite_accepted', {
      guild_id: guild.id,
      guild_name: guild.name
    })

    // Broadcast to guild that a new member joined
    this.broadcastToGuild(guild.id, 'guild_member_joined', {
      member: {
        id: '', // Will be filled by db
        guild_id: guild.id,
        player_id: client.session.player.id,
        role: 'member',
        joined_at: new Date().toISOString(),
        username: client.session.player.username,
        last_online: new Date().toISOString(),
        is_online: true
      }
    }, client.session.player.id) // Exclude self
  }

  private async handleDeclineGuildInvite(client: Client, payload: DeclineGuildInvitePayload) {
    if (!client.session) return

    const inviteId = payload?.invite_id
    if (!inviteId || typeof inviteId !== 'string') {
      this.sendError(client, 'Invite ID is required')
      return
    }

    const result = await declineGuildInvite(client.session.player.id, inviteId)

    if (!result.success) {
      this.send(client, 'guild_invite_error', { error: result.error })
      return
    }

    // Confirm decline to client
    this.send(client, 'guild_invite_declined', { invite_id: inviteId })

    // Optionally refresh their invite list
    const invites = await getIncomingGuildInvites(client.session.player.id)
    this.send(client, 'guild_invites_list', { invites })
  }

  private async handleCancelGuildInvite(client: Client, payload: CancelGuildInvitePayload) {
    if (!client.session) return

    const inviteId = payload?.invite_id
    if (!inviteId || typeof inviteId !== 'string') {
      this.sendError(client, 'Invite ID is required')
      return
    }

    // Check in guild with permission
    if (!client.session.guild) {
      this.sendError(client, 'You are not in a guild')
      return
    }

    if (!['leader', 'officer'].includes(client.session.guild.role)) {
      this.sendError(client, 'Only leaders and officers can cancel invites')
      return
    }

    const result = await cancelGuildInvite(client.session.player.id, inviteId)

    if (!result.success) {
      this.send(client, 'guild_invite_error', { error: result.error })
      return
    }

    // Confirm cancel to client
    this.send(client, 'guild_invite_cancelled', { invite_id: inviteId })

    // Refresh outgoing invites list
    const invites = await getOutgoingGuildInvites(client.session.guild.id)
    this.send(client, 'guild_outgoing_invites', { invites })
  }

  private async handleGetGuildInvites(client: Client) {
    if (!client.session) return

    const invites = await getIncomingGuildInvites(client.session.player.id)
    this.send(client, 'guild_invites_list', { invites })
  }

  private async handleGetOutgoingGuildInvites(client: Client) {
    if (!client.session) return

    if (!client.session.guild) {
      this.send(client, 'guild_outgoing_invites', { invites: [] })
      return
    }

    if (!['leader', 'officer'].includes(client.session.guild.role)) {
      this.send(client, 'guild_outgoing_invites', { invites: [] })
      return
    }

    const invites = await getOutgoingGuildInvites(client.session.guild.id)
    this.send(client, 'guild_outgoing_invites', { invites })
  }
```

4. **Add getSupabase import if not already present:**

At the top where db.ts imports are, ensure getSupabase is imported for the direct query:
```typescript
import { getSupabase, ... } from './db.js'
```
  </action>
  <verify>Run `npm run build` in apps/game-server. Check handler logic follows existing patterns.</verify>
  <done>WebSocket handlers added for all guild invite operations with real-time notifications and session updates.</done>
</task>

## Verification

- [ ] Database functions added to db.ts: sendGuildInvite, acceptGuildInvite, declineGuildInvite, cancelGuildInvite, getIncomingGuildInvites, getOutgoingGuildInvites
- [ ] Type imports added for GuildInvite, SendGuildInvitePayload, etc.
- [ ] Switch cases added for: guild_invite_send, guild_invite_accept, guild_invite_decline, guild_invite_cancel, get_guild_invites, get_guild_outgoing_invites
- [ ] handleSendGuildInvite includes isPlayerBlocked check
- [ ] handleSendGuildInvite notifies target via getClientByPlayerId
- [ ] handleAcceptGuildInvite updates client.session.guild
- [ ] handleAcceptGuildInvite broadcasts to guild via broadcastToGuild
- [ ] `npm run build` in apps/game-server completes without errors

## Success Criteria

- Leader/Officer can send invite to player not in a guild
- Target player receives real-time notification if online
- Player can accept invite and join guild as member
- Player can decline invite (removes from list)
- Leader/Officer can cancel sent invites
- Player can view pending invites received
- Leader/Officer can view outgoing invites from their guild
- Block system is respected (cannot invite blocked player)
- 24hr cooldown respected when accepting (enforced by database function)

## Output

After completion, create `.planning/phases/02-guild-invites/02-03-SUMMARY.md`
