---
phase: 01-guild-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - supabase/migrations/022_guilds.sql
  - apps/game-server/src/db.ts
  - apps/game-server/src/hub.ts
autonomous: true

must_haves:
  truths:
    - "Leader can promote member to officer"
    - "Leader can demote officer to member"
    - "Leader can kick any member (officer or member)"
    - "Officer can kick members but not officers"
    - "Leader can transfer leadership to another member"
    - "Leader can disband guild with confirmation"
    - "Role changes broadcast to all guild members"
  artifacts:
    - path: "supabase/migrations/022_guilds.sql"
      provides: "Role management database functions"
      contains: "promote_member|demote_member|kick_member|transfer_leadership|disband_guild"
    - path: "apps/game-server/src/hub.ts"
      provides: "Role management WebSocket handlers"
      contains: "handlePromoteMember|handleDemoteMember|handleKickMember"
  key_links:
    - from: "apps/game-server/src/hub.ts"
      to: "apps/game-server/src/db.ts"
      via: "function calls"
      pattern: "await promoteMember|demoteMember|kickMember"
    - from: "apps/game-server/src/db.ts"
      to: "supabase.rpc"
      via: "RPC calls"
      pattern: "supabase\\.rpc\\('promote_member"
---

# Plan 04: Role Management and Guild Administration

## Objective

Implement role-based permission system for guild management including promote, demote, kick, transfer leadership, and disband operations.

Purpose: Enable guild leaders and officers to manage their guild membership with proper permission enforcement.

Output: Complete role management system with database functions and WebSocket handlers.

## Context

**Existing patterns to follow:**
- Database functions with FOR UPDATE locking (009_trades.sql complete_trade pattern)
- Permission checks inside database transactions
- Hub handlers validating session state before calling db functions

**Dependencies:**
- 01-01 provides base schema (guilds, guild_members, guild_role enum)
- 01-02 provides shared types (payload interfaces)

**Requirements covered:**
- ROLE-02: Leader can promote Members to Officer
- ROLE-03: Leader can demote Officers to Member
- ROLE-04: Leader can transfer leadership to another member
- ROLE-05: Leader can kick any member (Officer or Member)
- ROLE-06: Officer can kick Members (not other Officers)
- ROLE-07: Leader can disband guild (requires confirmation)

## Tasks

<task type="auto">
  <name>Task 1: Add role management database functions</name>
  <files>supabase/migrations/022_guilds.sql</files>
  <action>
Append the following functions to `022_guilds.sql` (after the existing functions from Plan 01):

```sql
-- ================================
-- Role Management Functions
-- ================================

-- Promote a member to officer (leader only)
CREATE OR REPLACE FUNCTION promote_member(
  p_actor_id UUID,
  p_target_id UUID
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_actor RECORD;
  v_target RECORD;
BEGIN
  -- Lock actor's membership row and verify they're a leader
  SELECT gm.*, g.id as guild_id INTO v_actor
  FROM guild_members gm
  JOIN guilds g ON g.id = gm.guild_id
  WHERE gm.player_id = p_actor_id
  FOR UPDATE OF gm;

  IF v_actor IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'You are not in a guild');
  END IF;

  IF v_actor.role != 'leader' THEN
    RETURN json_build_object('success', false, 'error', 'Only the leader can promote members');
  END IF;

  -- Lock target's membership row
  SELECT * INTO v_target
  FROM guild_members
  WHERE player_id = p_target_id AND guild_id = v_actor.guild_id
  FOR UPDATE;

  IF v_target IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Player is not in your guild');
  END IF;

  IF v_target.role = 'leader' THEN
    RETURN json_build_object('success', false, 'error', 'Cannot promote the leader');
  END IF;

  IF v_target.role = 'officer' THEN
    RETURN json_build_object('success', false, 'error', 'Player is already an officer');
  END IF;

  -- Promote to officer
  UPDATE guild_members SET role = 'officer' WHERE player_id = p_target_id;

  RETURN json_build_object('success', true);
END;
$$;

-- Demote an officer to member (leader only)
CREATE OR REPLACE FUNCTION demote_member(
  p_actor_id UUID,
  p_target_id UUID
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_actor RECORD;
  v_target RECORD;
BEGIN
  -- Lock actor's membership row and verify they're a leader
  SELECT gm.*, g.id as guild_id INTO v_actor
  FROM guild_members gm
  JOIN guilds g ON g.id = gm.guild_id
  WHERE gm.player_id = p_actor_id
  FOR UPDATE OF gm;

  IF v_actor IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'You are not in a guild');
  END IF;

  IF v_actor.role != 'leader' THEN
    RETURN json_build_object('success', false, 'error', 'Only the leader can demote officers');
  END IF;

  -- Lock target's membership row
  SELECT * INTO v_target
  FROM guild_members
  WHERE player_id = p_target_id AND guild_id = v_actor.guild_id
  FOR UPDATE;

  IF v_target IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Player is not in your guild');
  END IF;

  IF v_target.role = 'leader' THEN
    RETURN json_build_object('success', false, 'error', 'Cannot demote the leader');
  END IF;

  IF v_target.role = 'member' THEN
    RETURN json_build_object('success', false, 'error', 'Player is already a member');
  END IF;

  -- Demote to member
  UPDATE guild_members SET role = 'member' WHERE player_id = p_target_id;

  RETURN json_build_object('success', true);
END;
$$;

-- Kick a member from guild (leader can kick anyone, officer can kick members)
CREATE OR REPLACE FUNCTION kick_member(
  p_actor_id UUID,
  p_target_id UUID
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_actor RECORD;
  v_target RECORD;
BEGIN
  -- Lock actor's membership row
  SELECT gm.*, g.id as guild_id INTO v_actor
  FROM guild_members gm
  JOIN guilds g ON g.id = gm.guild_id
  WHERE gm.player_id = p_actor_id
  FOR UPDATE OF gm;

  IF v_actor IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'You are not in a guild');
  END IF;

  IF v_actor.role = 'member' THEN
    RETURN json_build_object('success', false, 'error', 'Members cannot kick other members');
  END IF;

  -- Lock target's membership row
  SELECT * INTO v_target
  FROM guild_members
  WHERE player_id = p_target_id AND guild_id = v_actor.guild_id
  FOR UPDATE;

  IF v_target IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Player is not in your guild');
  END IF;

  IF v_target.role = 'leader' THEN
    RETURN json_build_object('success', false, 'error', 'Cannot kick the leader');
  END IF;

  -- Officers can only kick members, not other officers
  IF v_actor.role = 'officer' AND v_target.role = 'officer' THEN
    RETURN json_build_object('success', false, 'error', 'Officers cannot kick other officers');
  END IF;

  -- Remove member (triggers sync_player_guild_id which sets left_guild_at)
  DELETE FROM guild_members WHERE player_id = p_target_id;

  -- Update member count
  UPDATE guilds SET member_count = member_count - 1 WHERE id = v_actor.guild_id;

  RETURN json_build_object('success', true, 'guild_id', v_actor.guild_id);
END;
$$;

-- Transfer leadership to another member (leader only)
CREATE OR REPLACE FUNCTION transfer_leadership(
  p_actor_id UUID,
  p_target_id UUID
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_actor RECORD;
  v_target RECORD;
BEGIN
  -- Lock actor's membership row and verify they're a leader
  SELECT gm.*, g.id as guild_id INTO v_actor
  FROM guild_members gm
  JOIN guilds g ON g.id = gm.guild_id
  WHERE gm.player_id = p_actor_id
  FOR UPDATE OF gm;

  IF v_actor IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'You are not in a guild');
  END IF;

  IF v_actor.role != 'leader' THEN
    RETURN json_build_object('success', false, 'error', 'Only the leader can transfer leadership');
  END IF;

  -- Lock target's membership row
  SELECT * INTO v_target
  FROM guild_members
  WHERE player_id = p_target_id AND guild_id = v_actor.guild_id
  FOR UPDATE;

  IF v_target IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Player is not in your guild');
  END IF;

  IF v_target.player_id = p_actor_id THEN
    RETURN json_build_object('success', false, 'error', 'You are already the leader');
  END IF;

  -- Transfer: demote old leader to officer, promote new leader
  UPDATE guild_members SET role = 'officer' WHERE player_id = p_actor_id;
  UPDATE guild_members SET role = 'leader' WHERE player_id = p_target_id;

  -- Update guilds.leader_id
  UPDATE guilds SET leader_id = p_target_id WHERE id = v_actor.guild_id;

  RETURN json_build_object('success', true);
END;
$$;

-- Disband guild (leader only, requires guild name confirmation)
CREATE OR REPLACE FUNCTION disband_guild(
  p_actor_id UUID,
  p_confirmation TEXT
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_actor RECORD;
  v_guild RECORD;
BEGIN
  -- Lock actor's membership row and get guild
  SELECT gm.*, g.id as guild_id, g.name as guild_name INTO v_actor
  FROM guild_members gm
  JOIN guilds g ON g.id = gm.guild_id
  WHERE gm.player_id = p_actor_id
  FOR UPDATE OF gm;

  IF v_actor IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'You are not in a guild');
  END IF;

  IF v_actor.role != 'leader' THEN
    RETURN json_build_object('success', false, 'error', 'Only the leader can disband the guild');
  END IF;

  -- Verify confirmation matches guild name (case-insensitive)
  IF LOWER(TRIM(p_confirmation)) != LOWER(v_actor.guild_name) THEN
    RETURN json_build_object('success', false, 'error', 'Confirmation does not match guild name');
  END IF;

  -- Store guild name for response before deletion
  -- Delete guild (cascades to guild_members, triggers sync_player_guild_id for all members)
  DELETE FROM guilds WHERE id = v_actor.guild_id;

  RETURN json_build_object('success', true, 'guild_name', v_actor.guild_name);
END;
$$;
```
  </action>
  <verify>Review FOR UPDATE locking covers all necessary rows. Verify role hierarchy is enforced correctly. Check cascade delete on guild removes all members.</verify>
  <done>Five role management functions added with proper locking and permission enforcement.</done>
</task>

<task type="auto">
  <name>Task 2: Add role management database wrappers to db.ts</name>
  <files>apps/game-server/src/db.ts</files>
  <action>
Add the following functions to `apps/game-server/src/db.ts` (in the Guild Functions section):

```typescript
// Promote a member to officer (leader only)
export async function promoteMember(
  actorId: string,
  targetId: string
): Promise<{ success: boolean; error?: string }> {
  const { data, error } = await supabase.rpc('promote_member', {
    p_actor_id: actorId,
    p_target_id: targetId
  })

  if (error) {
    console.error('Error promoting member:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; error?: string }
}

// Demote an officer to member (leader only)
export async function demoteMember(
  actorId: string,
  targetId: string
): Promise<{ success: boolean; error?: string }> {
  const { data, error } = await supabase.rpc('demote_member', {
    p_actor_id: actorId,
    p_target_id: targetId
  })

  if (error) {
    console.error('Error demoting member:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; error?: string }
}

// Kick a member from guild
export async function kickMember(
  actorId: string,
  targetId: string
): Promise<{ success: boolean; guild_id?: string; error?: string }> {
  const { data, error } = await supabase.rpc('kick_member', {
    p_actor_id: actorId,
    p_target_id: targetId
  })

  if (error) {
    console.error('Error kicking member:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; guild_id?: string; error?: string }
}

// Transfer leadership to another member (leader only)
export async function transferLeadership(
  actorId: string,
  targetId: string
): Promise<{ success: boolean; error?: string }> {
  const { data, error } = await supabase.rpc('transfer_leadership', {
    p_actor_id: actorId,
    p_target_id: targetId
  })

  if (error) {
    console.error('Error transferring leadership:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; error?: string }
}

// Disband guild (leader only, requires confirmation)
export async function disbandGuild(
  actorId: string,
  confirmation: string
): Promise<{ success: boolean; guild_name?: string; error?: string }> {
  const { data, error } = await supabase.rpc('disband_guild', {
    p_actor_id: actorId,
    p_confirmation: confirmation
  })

  if (error) {
    console.error('Error disbanding guild:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; guild_name?: string; error?: string }
}

// Get member info by player ID (for notifications)
export async function getGuildMemberByPlayerId(
  playerId: string
): Promise<{ username: string; role: string } | null> {
  const { data, error } = await supabase
    .from('guild_members')
    .select(`
      role,
      players!inner (username)
    `)
    .eq('player_id', playerId)
    .single()

  if (error || !data) return null

  return {
    username: (data as any).players.username,
    role: data.role
  }
}
```
  </action>
  <verify>Verify function signatures match the database function parameters. Check error handling is consistent.</verify>
  <done>Database wrapper functions added for all role management operations.</done>
</task>

<task type="auto">
  <name>Task 3: Add role management handlers to hub.ts</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
1. **Add imports:**

```typescript
import type {
  // ... existing imports ...
  PromoteMemberPayload,
  DemoteMemberPayload,
  KickMemberPayload,
  TransferLeadershipPayload,
  DisbandGuildPayload
} from './types.js'

import {
  // ... existing imports ...
  promoteMember,
  demoteMember,
  kickMember,
  transferLeadership,
  disbandGuild,
  getGuildMemberByPlayerId
} from './db.js'
```

2. **Add message handlers in handleMessage switch:**

```typescript
case 'promote_member':
  await this.handlePromoteMember(client, message.payload as PromoteMemberPayload)
  break

case 'demote_member':
  await this.handleDemoteMember(client, message.payload as DemoteMemberPayload)
  break

case 'kick_member':
  await this.handleKickMember(client, message.payload as KickMemberPayload)
  break

case 'transfer_leadership':
  await this.handleTransferLeadership(client, message.payload as TransferLeadershipPayload)
  break

case 'disband_guild':
  await this.handleDisbandGuild(client, message.payload as DisbandGuildPayload)
  break
```

3. **Implement handler methods:**

```typescript
private async handlePromoteMember(client: Client, payload: PromoteMemberPayload) {
  if (!client.session?.guild) {
    this.sendError(client, 'Not in a guild')
    return
  }

  if (!payload.player_id) {
    this.sendError(client, 'Player ID is required')
    return
  }

  const result = await promoteMember(client.session.player.id, payload.player_id)

  if (!result.success) {
    this.send(client, 'guild_error', { error: result.error })
    return
  }

  // Get target's username for broadcast
  const targetInfo = await getGuildMemberByPlayerId(payload.player_id)
  if (!targetInfo) {
    this.sendError(client, 'Failed to get member info')
    return
  }

  // Update target's session if online
  this.updatePlayerGuildRole(payload.player_id, 'officer')

  // Broadcast role change to guild
  this.broadcastToGuild(client.session.guild.id, 'guild_role_changed', {
    player_id: payload.player_id,
    username: targetInfo.username,
    old_role: 'member',
    new_role: 'officer'
  })
}

private async handleDemoteMember(client: Client, payload: DemoteMemberPayload) {
  if (!client.session?.guild) {
    this.sendError(client, 'Not in a guild')
    return
  }

  if (!payload.player_id) {
    this.sendError(client, 'Player ID is required')
    return
  }

  const result = await demoteMember(client.session.player.id, payload.player_id)

  if (!result.success) {
    this.send(client, 'guild_error', { error: result.error })
    return
  }

  // Get target's username for broadcast
  const targetInfo = await getGuildMemberByPlayerId(payload.player_id)
  if (!targetInfo) {
    this.sendError(client, 'Failed to get member info')
    return
  }

  // Update target's session if online
  this.updatePlayerGuildRole(payload.player_id, 'member')

  // Broadcast role change to guild
  this.broadcastToGuild(client.session.guild.id, 'guild_role_changed', {
    player_id: payload.player_id,
    username: targetInfo.username,
    old_role: 'officer',
    new_role: 'member'
  })
}

private async handleKickMember(client: Client, payload: KickMemberPayload) {
  if (!client.session?.guild) {
    this.sendError(client, 'Not in a guild')
    return
  }

  if (!payload.player_id) {
    this.sendError(client, 'Player ID is required')
    return
  }

  // Get target info before kick (for notification)
  const targetInfo = await getGuildMemberByPlayerId(payload.player_id)
  if (!targetInfo) {
    this.sendError(client, 'Player not found')
    return
  }

  const guildId = client.session.guild.id
  const result = await kickMember(client.session.player.id, payload.player_id)

  if (!result.success) {
    this.send(client, 'guild_error', { error: result.error })
    return
  }

  // Clear kicked player's session guild if online
  this.clearPlayerGuild(payload.player_id)

  // Notify kicked player if online
  this.sendToPlayer(payload.player_id, 'guild_kicked', {
    kicked_by: client.session.player.username
  })

  // Broadcast to remaining guild members
  this.broadcastToGuild(guildId, 'guild_member_kicked', {
    player_id: payload.player_id,
    username: targetInfo.username,
    kicked_by: client.session.player.username
  })
}

private async handleTransferLeadership(client: Client, payload: TransferLeadershipPayload) {
  if (!client.session?.guild) {
    this.sendError(client, 'Not in a guild')
    return
  }

  if (!payload.player_id) {
    this.sendError(client, 'Player ID is required')
    return
  }

  const result = await transferLeadership(client.session.player.id, payload.player_id)

  if (!result.success) {
    this.send(client, 'guild_error', { error: result.error })
    return
  }

  // Get new leader's username for broadcast
  const newLeaderInfo = await getGuildMemberByPlayerId(payload.player_id)
  if (!newLeaderInfo) {
    this.sendError(client, 'Failed to get member info')
    return
  }

  // Update both players' sessions
  this.updatePlayerGuildRole(client.session.player.id, 'officer')
  this.updatePlayerGuildRole(payload.player_id, 'leader')

  // Update actor's local session
  client.session.guild.role = 'officer'

  // Broadcast both role changes to guild
  this.broadcastToGuild(client.session.guild.id, 'guild_role_changed', {
    player_id: client.session.player.id,
    username: client.session.player.username,
    old_role: 'leader',
    new_role: 'officer'
  })

  this.broadcastToGuild(client.session.guild.id, 'guild_role_changed', {
    player_id: payload.player_id,
    username: newLeaderInfo.username,
    old_role: newLeaderInfo.role,
    new_role: 'leader'
  })
}

private async handleDisbandGuild(client: Client, payload: DisbandGuildPayload) {
  if (!client.session?.guild) {
    this.sendError(client, 'Not in a guild')
    return
  }

  if (!payload.confirmation) {
    this.sendError(client, 'Confirmation is required')
    return
  }

  const guildId = client.session.guild.id
  const result = await disbandGuild(client.session.player.id, payload.confirmation)

  if (!result.success) {
    this.send(client, 'guild_error', { error: result.error })
    return
  }

  // Broadcast disbandment to all guild members (clears their sessions)
  this.broadcastToGuild(guildId, 'guild_disbanded', {
    guild_name: result.guild_name
  })

  // Clear all members' guild sessions
  for (const [, c] of this.clients) {
    if (c.session?.guild?.id === guildId) {
      c.session.guild = undefined
    }
  }
}

// Helper: Update a player's guild role in their session
private updatePlayerGuildRole(playerId: string, newRole: GuildRole) {
  for (const [, c] of this.clients) {
    if (c.session?.player.id === playerId && c.session.guild) {
      c.session.guild.role = newRole
      break
    }
  }
}

// Helper: Clear a player's guild from their session
private clearPlayerGuild(playerId: string) {
  for (const [, c] of this.clients) {
    if (c.session?.player.id === playerId) {
      c.session.guild = undefined
      break
    }
  }
}

// Helper: Send message to specific player by ID
private sendToPlayer(playerId: string, type: string, payload: unknown) {
  for (const [, c] of this.clients) {
    if (c.session?.player.id === playerId) {
      this.send(c, type, payload)
      break
    }
  }
}
```

4. **Add GuildRole type import:**

```typescript
import type { GuildRole } from './types.js'
```
  </action>
  <verify>Review handler logic for all edge cases. Verify session updates happen correctly. Ensure broadcasts go to correct recipients.</verify>
  <done>All role management handlers implemented with proper permission enforcement, session updates, and guild broadcasts.</done>
</task>

## Verification

- [ ] 022_guilds.sql contains promote_member, demote_member, kick_member, transfer_leadership, disband_guild functions
- [ ] All functions use FOR UPDATE locking
- [ ] All functions verify actor has required role before proceeding
- [ ] kick_member enforces: leader can kick anyone, officer can only kick members
- [ ] disband_guild requires confirmation matching guild name
- [ ] db.ts has wrapper functions for all role management operations
- [ ] hub.ts handles promote_member, demote_member, kick_member, transfer_leadership, disband_guild messages
- [ ] hub.ts broadcasts role changes to all guild members
- [ ] hub.ts updates player sessions when roles change or players are kicked
- [ ] Game server compiles without errors

## Success Criteria

- Leader can promote member to officer via WebSocket
- Leader can demote officer to member via WebSocket
- Leader can kick any member via WebSocket
- Officer can kick members but receives error when trying to kick officers
- Leader can transfer leadership; both players' roles update
- Leader can disband guild by typing exact guild name
- All role changes broadcast to online guild members in real-time
- Kicked players receive notification and their session is cleared

## Output

After completion, create `.planning/phases/01-guild-foundation/01-04-SUMMARY.md`
