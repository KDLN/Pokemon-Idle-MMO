---
phase: 01-guild-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - apps/game-server/src/types.ts
  - apps/game-server/src/db.ts
  - apps/game-server/src/hub.ts
autonomous: true

must_haves:
  truths:
    - "Game server handles create_guild message and creates guild in database"
    - "Game server handles join_guild message for open guilds"
    - "Game server handles leave_guild message with cooldown enforcement"
    - "Game server handles get_guild and get_guild_members messages"
    - "Game server handles search_guilds message with pagination"
    - "PlayerSession caches guild info for fast membership checks"
    - "broadcastToGuild sends messages only to guild members"
  artifacts:
    - path: "apps/game-server/src/db.ts"
      provides: "Guild database query functions"
      exports: ["createGuild", "joinGuild", "leaveGuild", "getGuildById", "getGuildMembers", "searchGuilds"]
    - path: "apps/game-server/src/hub.ts"
      provides: "WebSocket message handlers for guild operations"
      contains: "handleCreateGuild"
  key_links:
    - from: "apps/game-server/src/hub.ts"
      to: "apps/game-server/src/db.ts"
      via: "function calls"
      pattern: "await createGuild|joinGuild|leaveGuild"
    - from: "apps/game-server/src/hub.ts"
      to: "PlayerSession"
      via: "session.guild property"
      pattern: "client\\.session\\.guild"
---

# Plan 03: Game Server Guild Handlers

## Objective

Implement WebSocket message handlers for guild creation, joining, leaving, and viewing in the game server.

Purpose: Enable players to create and manage guild membership through the WebSocket connection.

Output: Game server can process guild lifecycle messages and broadcast updates to guild members.

## Context

**Existing patterns to follow:**
- `apps/game-server/src/hub.ts` - Message handling (handleChatMessage, handleFriendRequest, etc.)
- `apps/game-server/src/db.ts` - Database queries using supabase.rpc() for functions
- `apps/game-server/src/types.ts` - PlayerSession interface, type re-exports

**Dependencies:**
- 01-01 provides database schema and functions (create_guild, join_guild, leave_guild)
- 01-02 provides shared types (Guild, GuildMember, GuildRole, payload interfaces)

**Requirements covered:**
- GUILD-01: Create guild with name, tag, description
- GUILD-02: 50 member cap enforcement (in join_guild function)
- GUILD-03: View list of guilds with search/filter
- GUILD-04: Join open guild directly
- GUILD-05: Leave guild (24hr cooldown in leave_guild function)
- GUILD-06: View guild member roster with online status, role, last active
- GUILD-07: Founder becomes Leader (in create_guild function)

## Tasks

<task type="auto">
  <name>Task 1: Add guild types to game server and extend PlayerSession</name>
  <files>apps/game-server/src/types.ts</files>
  <action>
1. **Add guild type re-exports to the type re-export block:**

```typescript
export type {
  // ... existing exports ...
  // Guild
  Guild,
  GuildMember,
  GuildRole,
  GuildJoinMode,
  GuildPreview,
  PlayerGuildInfo,
  CreateGuildPayload,
  JoinGuildPayload,
  SearchGuildsPayload,
  UpdateGuildSettingsPayload,
  GuildDataPayload,
  GuildListPayload,
  GuildMemberJoinedPayload,
  GuildMemberLeftPayload,
  GuildErrorPayload,
} from '@pokemon-idle/shared'
```

2. **Extend PlayerSession interface** (add guild field):

```typescript
export interface PlayerSession {
  // ... existing fields ...

  // Guild state (loaded on connect, updated on guild changes)
  guild?: PlayerGuildInfo
}
```

Note: PlayerGuildInfo is a lightweight object: { id, name, tag, role }
  </action>
  <verify>Ensure no duplicate type exports. Verify PlayerSession extension doesn't break existing code.</verify>
  <done>Guild types re-exported and PlayerSession extended with optional guild field.</done>
</task>

<task type="auto">
  <name>Task 2: Add guild database functions to db.ts</name>
  <files>apps/game-server/src/db.ts</files>
  <action>
Add the following functions to `apps/game-server/src/db.ts`:

```typescript
// ================================
// Guild Functions
// ================================

// Create a new guild (calls database function)
export async function createGuild(
  playerId: string,
  name: string,
  tag: string,
  description?: string
): Promise<{ success: boolean; guild_id?: string; error?: string }> {
  const { data, error } = await supabase.rpc('create_guild', {
    p_player_id: playerId,
    p_name: name,
    p_tag: tag,
    p_description: description || null
  })

  if (error) {
    console.error('Error creating guild:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; guild_id?: string; error?: string }
}

// Join an open guild (calls database function)
export async function joinGuild(
  playerId: string,
  guildId: string
): Promise<{ success: boolean; error?: string }> {
  const { data, error } = await supabase.rpc('join_guild', {
    p_player_id: playerId,
    p_guild_id: guildId
  })

  if (error) {
    console.error('Error joining guild:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; error?: string }
}

// Leave current guild (calls database function)
export async function leaveGuild(
  playerId: string
): Promise<{ success: boolean; guild_disbanded?: boolean; error?: string }> {
  const { data, error } = await supabase.rpc('leave_guild', {
    p_player_id: playerId
  })

  if (error) {
    console.error('Error leaving guild:', error)
    return { success: false, error: 'Database error' }
  }

  return data as { success: boolean; guild_disbanded?: boolean; error?: string }
}

// Get guild by ID with full details
export async function getGuildById(guildId: string): Promise<Guild | null> {
  const { data, error } = await supabase
    .from('guilds')
    .select('*')
    .eq('id', guildId)
    .single()

  if (error || !data) return null
  return data as Guild
}

// Get guild members with player info, sorted by role then join date
export async function getGuildMembers(guildId: string): Promise<GuildMember[]> {
  const { data, error } = await supabase
    .from('guild_members')
    .select(`
      id,
      guild_id,
      player_id,
      role,
      joined_at,
      players!inner (
        username,
        last_online
      )
    `)
    .eq('guild_id', guildId)
    .order('role', { ascending: true })  // leader first, then officer, then member
    .order('joined_at', { ascending: true })

  if (error || !data) return []

  // Transform to flatten players join
  return data.map((m: any) => ({
    id: m.id,
    guild_id: m.guild_id,
    player_id: m.player_id,
    role: m.role,
    joined_at: m.joined_at,
    username: m.players.username,
    last_online: m.players.last_online
  }))
}

// Get player's current guild info (for session loading)
export async function getPlayerGuild(playerId: string): Promise<PlayerGuildInfo | null> {
  const { data, error } = await supabase
    .from('guild_members')
    .select(`
      role,
      guilds!inner (
        id,
        name,
        tag
      )
    `)
    .eq('player_id', playerId)
    .single()

  if (error || !data) return null

  const d = data as any
  return {
    id: d.guilds.id,
    name: d.guilds.name,
    tag: d.guilds.tag,
    role: d.role
  }
}

// Search/list guilds with pagination
export async function searchGuilds(
  query?: string,
  page: number = 1,
  limit: number = 20
): Promise<{ guilds: GuildPreview[]; total: number }> {
  const offset = (page - 1) * limit

  let queryBuilder = supabase
    .from('guilds')
    .select('id, name, tag, description, member_count, max_members, join_mode', { count: 'exact' })

  // Filter by search query if provided
  if (query && query.trim()) {
    const searchTerm = `%${query.trim()}%`
    queryBuilder = queryBuilder.or(`name.ilike.${searchTerm},tag.ilike.${searchTerm}`)
  }

  const { data, error, count } = await queryBuilder
    .order('member_count', { ascending: false })
    .range(offset, offset + limit - 1)

  if (error) {
    console.error('Error searching guilds:', error)
    return { guilds: [], total: 0 }
  }

  return {
    guilds: (data || []) as GuildPreview[],
    total: count || 0
  }
}
```

Import required types at the top of the file:
```typescript
import type { Guild, GuildMember, GuildPreview, PlayerGuildInfo } from './types.js'
```
  </action>
  <verify>Review Supabase query syntax. Ensure JOIN syntax is correct for supabase-js. Check error handling follows existing patterns.</verify>
  <done>Database functions added for all guild CRUD operations with proper error handling.</done>
</task>

<task type="auto">
  <name>Task 3: Add guild message handlers to hub.ts</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
1. **Add imports at top of hub.ts:**

```typescript
import type {
  // ... existing imports ...
  CreateGuildPayload,
  JoinGuildPayload,
  SearchGuildsPayload,
  PlayerGuildInfo
} from './types.js'

import {
  // ... existing imports ...
  createGuild,
  joinGuild,
  leaveGuild,
  getGuildById,
  getGuildMembers,
  getPlayerGuild,
  searchGuilds
} from './db.js'
```

2. **Add broadcastToGuild helper method** (after existing broadcast method):

```typescript
// Broadcast message to all online members of a guild
private broadcastToGuild(guildId: string, type: string, payload: unknown) {
  for (const [, client] of this.clients) {
    if (client.session?.guild?.id === guildId) {
      this.send(client, type, payload)
    }
  }
}
```

3. **Load guild info on player connect** (in the connection handler where PlayerSession is initialized):

Find where PlayerSession is created after JWT validation. After loading player data, add:

```typescript
// Load guild membership if any
const guildInfo = await getPlayerGuild(player.id)
if (guildInfo) {
  session.guild = guildInfo
}
```

4. **Add message handlers in handleMessage switch statement:**

```typescript
case 'create_guild':
  await this.handleCreateGuild(client, message.payload as CreateGuildPayload)
  break

case 'join_guild':
  await this.handleJoinGuild(client, message.payload as JoinGuildPayload)
  break

case 'leave_guild':
  await this.handleLeaveGuild(client)
  break

case 'get_guild':
  await this.handleGetGuild(client)
  break

case 'get_guild_members':
  await this.handleGetGuildMembers(client)
  break

case 'search_guilds':
  await this.handleSearchGuilds(client, message.payload as SearchGuildsPayload)
  break
```

5. **Implement handler methods:**

```typescript
private async handleCreateGuild(client: Client, payload: CreateGuildPayload) {
  if (!client.session) return

  // Validate payload
  if (!payload.name || !payload.tag) {
    this.sendError(client, 'Name and tag are required')
    return
  }

  // Check not already in guild
  if (client.session.guild) {
    this.sendError(client, 'Already in a guild')
    return
  }

  const result = await createGuild(
    client.session.player.id,
    payload.name,
    payload.tag,
    payload.description
  )

  if (!result.success) {
    this.send(client, 'guild_error', { error: result.error })
    return
  }

  // Load full guild data
  const guild = await getGuildById(result.guild_id!)
  if (!guild) {
    this.sendError(client, 'Failed to load created guild')
    return
  }

  // Update session
  client.session.guild = {
    id: guild.id,
    name: guild.name,
    tag: guild.tag,
    role: 'leader'
  }

  // Send guild data to creator
  const members = await getGuildMembers(guild.id)
  this.send(client, 'guild_data', {
    guild,
    members: members.map(m => ({
      ...m,
      is_online: this.isPlayerOnline(m.player_id)
    })),
    my_role: 'leader'
  })
}

private async handleJoinGuild(client: Client, payload: JoinGuildPayload) {
  if (!client.session) return

  if (!payload.guild_id) {
    this.sendError(client, 'Guild ID is required')
    return
  }

  if (client.session.guild) {
    this.sendError(client, 'Already in a guild')
    return
  }

  const result = await joinGuild(client.session.player.id, payload.guild_id)

  if (!result.success) {
    this.send(client, 'guild_error', { error: result.error })
    return
  }

  // Load guild data
  const guild = await getGuildById(payload.guild_id)
  if (!guild) {
    this.sendError(client, 'Failed to load guild')
    return
  }

  // Update session
  client.session.guild = {
    id: guild.id,
    name: guild.name,
    tag: guild.tag,
    role: 'member'
  }

  // Notify guild members of new join
  this.broadcastToGuild(guild.id, 'guild_member_joined', {
    member: {
      id: '', // Will be set by DB
      guild_id: guild.id,
      player_id: client.session.player.id,
      role: 'member',
      joined_at: new Date().toISOString(),
      username: client.session.player.username,
      last_online: null,
      is_online: true
    }
  })

  // Send full guild data to joiner
  const members = await getGuildMembers(guild.id)
  this.send(client, 'guild_data', {
    guild,
    members: members.map(m => ({
      ...m,
      is_online: this.isPlayerOnline(m.player_id)
    })),
    my_role: 'member'
  })
}

private async handleLeaveGuild(client: Client) {
  if (!client.session) return

  if (!client.session.guild) {
    this.sendError(client, 'Not in a guild')
    return
  }

  const guildId = client.session.guild.id
  const guildName = client.session.guild.name
  const username = client.session.player.username
  const playerId = client.session.player.id

  const result = await leaveGuild(playerId)

  if (!result.success) {
    this.send(client, 'guild_error', { error: result.error })
    return
  }

  // Clear session guild
  client.session.guild = undefined

  if (result.guild_disbanded) {
    // Notify all members guild is disbanded (they won't be in guild anymore)
    this.send(client, 'guild_disbanded', { guild_name: guildName })
  } else {
    // Notify remaining members
    this.broadcastToGuild(guildId, 'guild_member_left', {
      player_id: playerId,
      username: username
    })

    // Confirm to leaver
    this.send(client, 'guild_left', { success: true })
  }
}

private async handleGetGuild(client: Client) {
  if (!client.session) return

  if (!client.session.guild) {
    this.send(client, 'guild_data', { guild: null, members: [], my_role: null })
    return
  }

  const guild = await getGuildById(client.session.guild.id)
  if (!guild) {
    // Guild was deleted, clear session
    client.session.guild = undefined
    this.send(client, 'guild_data', { guild: null, members: [], my_role: null })
    return
  }

  const members = await getGuildMembers(guild.id)
  this.send(client, 'guild_data', {
    guild,
    members: members.map(m => ({
      ...m,
      is_online: this.isPlayerOnline(m.player_id)
    })),
    my_role: client.session.guild.role
  })
}

private async handleGetGuildMembers(client: Client) {
  if (!client.session?.guild) {
    this.sendError(client, 'Not in a guild')
    return
  }

  const members = await getGuildMembers(client.session.guild.id)
  this.send(client, 'guild_members', {
    members: members.map(m => ({
      ...m,
      is_online: this.isPlayerOnline(m.player_id)
    }))
  })
}

private async handleSearchGuilds(client: Client, payload: SearchGuildsPayload) {
  if (!client.session) return

  const { guilds, total } = await searchGuilds(
    payload.query,
    payload.page || 1,
    payload.limit || 20
  )

  this.send(client, 'guild_list', {
    guilds,
    total,
    page: payload.page || 1
  })
}

// Helper to check if player is online
private isPlayerOnline(playerId: string): boolean {
  for (const [, client] of this.clients) {
    if (client.session?.player.id === playerId) {
      return true
    }
  }
  return false
}
```
  </action>
  <verify>Review handler logic for edge cases. Ensure session.guild is updated correctly. Verify broadcastToGuild works with guild membership check.</verify>
  <done>All guild lifecycle handlers implemented with proper session management and guild broadcasts.</done>
</task>

## Verification

- [ ] types.ts re-exports guild types from shared package
- [ ] PlayerSession interface has optional guild field
- [ ] db.ts has createGuild, joinGuild, leaveGuild functions calling RPC
- [ ] db.ts has getGuildById, getGuildMembers, getPlayerGuild, searchGuilds query functions
- [ ] hub.ts has broadcastToGuild helper method
- [ ] hub.ts loads guild info into session on player connect
- [ ] hub.ts handles create_guild, join_guild, leave_guild messages
- [ ] hub.ts handles get_guild, get_guild_members, search_guilds messages
- [ ] Game server compiles without TypeScript errors: `cd apps/game-server && npm run build`

## Success Criteria

- Player can create guild via WebSocket, receives guild_data response
- Player can join open guild via WebSocket, all guild members receive guild_member_joined
- Player can leave guild via WebSocket, remaining members receive guild_member_left
- Player can view their guild and members via get_guild
- Player can search guilds via search_guilds with pagination
- Online status is calculated correctly for guild members

## Output

After completion, create `.planning/phases/01-guild-foundation/01-03-SUMMARY.md`
