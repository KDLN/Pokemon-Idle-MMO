---
phase: 01-guild-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/022_guilds.sql
autonomous: true

must_haves:
  truths:
    - "Guild table exists with all required columns"
    - "Guild members table tracks membership and roles"
    - "Players table has guild_id for fast lookups"
    - "RLS policies protect guild data appropriately"
    - "Database functions handle atomic guild creation"
  artifacts:
    - path: "supabase/migrations/022_guilds.sql"
      provides: "Guild schema, RLS policies, and functions"
      contains: "CREATE TABLE guilds"
  key_links:
    - from: "guild_members"
      to: "guilds"
      via: "foreign key guild_id"
      pattern: "REFERENCES guilds\\(id\\)"
    - from: "guild_members"
      to: "players"
      via: "foreign key player_id"
      pattern: "REFERENCES players\\(id\\)"
---

# Plan 01: Database Schema for Guilds

## Objective

Create the foundational database schema for the guild system including tables, enums, indexes, RLS policies, and atomic database functions.

Purpose: This schema enables all guild operations and must be complete before game server or frontend work can begin.

Output: Migration file `022_guilds.sql` ready to apply via Supabase Dashboard SQL Editor.

## Context

**Existing patterns to follow:**
- `007_friends.sql` - Social table patterns with friend_status enum, RLS policies
- `009_trades.sql` - Complex atomic operations with SECURITY DEFINER functions, FOR UPDATE locking
- `018_week5_social.sql` - Block system patterns

**Next migration number:** 022 (after 021_performance_indexes.sql)

**Requirements covered:**
- GUILD-01: Create guild with name, tag, description
- GUILD-02: 50 member maximum cap
- GUILD-05: 24hr cooldown tracking (left_guild_at column)
- GUILD-07: Founder becomes Leader
- ROLE-01: Three roles (leader, officer, member)

## Tasks

<task type="auto">
  <name>Task 1: Create core guild tables and enums</name>
  <files>supabase/migrations/022_guilds.sql</files>
  <action>
Create migration file with:

1. **guild_role enum:**
```sql
CREATE TYPE guild_role AS ENUM ('leader', 'officer', 'member');
```

2. **guilds table:**
- id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
- name: TEXT UNIQUE NOT NULL (3-30 chars, alphanumeric + spaces)
- tag: TEXT UNIQUE NOT NULL (2-5 chars uppercase, alphanumeric only)
- description: TEXT (max 500 chars)
- leader_id: UUID REFERENCES players(id) ON DELETE RESTRICT NOT NULL
- member_count: INT DEFAULT 1 (denormalized for performance)
- max_members: INT DEFAULT 50
- join_mode: TEXT DEFAULT 'open' CHECK (join_mode IN ('open', 'invite_only', 'closed'))
- created_at: TIMESTAMPTZ DEFAULT NOW()

Constraints:
- guild_name_length: char_length(name) >= 3 AND char_length(name) <= 30
- guild_name_format: name ~ '^[a-zA-Z0-9 ]+$'
- guild_tag_length: char_length(tag) >= 2 AND char_length(tag) <= 5
- guild_tag_format: tag ~ '^[A-Z0-9]+$'

3. **guild_members table:**
- id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
- guild_id: UUID REFERENCES guilds(id) ON DELETE CASCADE NOT NULL
- player_id: UUID REFERENCES players(id) ON DELETE CASCADE NOT NULL
- role: guild_role NOT NULL DEFAULT 'member'
- joined_at: TIMESTAMPTZ DEFAULT NOW()

Constraints:
- unique_player_guild: UNIQUE (player_id) -- Player can only be in one guild
- unique_guild_member: UNIQUE (guild_id, player_id)

4. **Partial unique index for single leader:**
```sql
CREATE UNIQUE INDEX idx_one_leader_per_guild ON guild_members(guild_id) WHERE role = 'leader';
```

5. **Add columns to players table:**
```sql
ALTER TABLE players ADD COLUMN guild_id UUID REFERENCES guilds(id) ON DELETE SET NULL;
ALTER TABLE players ADD COLUMN left_guild_at TIMESTAMPTZ;
CREATE INDEX idx_players_guild ON players(guild_id) WHERE guild_id IS NOT NULL;
```

6. **Trigger to sync players.guild_id with guild_members:**
```sql
CREATE OR REPLACE FUNCTION sync_player_guild_id()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE players SET guild_id = NEW.guild_id WHERE id = NEW.player_id;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE players SET guild_id = NULL, left_guild_at = NOW() WHERE id = OLD.player_id;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_sync_player_guild
AFTER INSERT OR DELETE ON guild_members
FOR EACH ROW EXECUTE FUNCTION sync_player_guild_id();
```

7. **Standard indexes:**
```sql
CREATE INDEX idx_guilds_leader ON guilds(leader_id);
CREATE INDEX idx_guilds_name ON guilds(LOWER(name));
CREATE INDEX idx_guild_members_guild ON guild_members(guild_id);
CREATE INDEX idx_guild_members_player ON guild_members(player_id);
CREATE INDEX idx_guild_members_role ON guild_members(guild_id, role);
```
  </action>
  <verify>Review migration SQL for syntax errors. Check constraint names don't conflict with existing schema.</verify>
  <done>Migration file contains guilds table, guild_members table, guild_role enum, all constraints, indexes, and trigger for guild_id sync.</done>
</task>

<task type="auto">
  <name>Task 2: Add RLS policies for guild data</name>
  <files>supabase/migrations/022_guilds.sql</files>
  <action>
Append RLS policies to the migration file:

1. **guilds table RLS:**
```sql
ALTER TABLE guilds ENABLE ROW LEVEL SECURITY;

-- Anyone can view guilds (for discovery/search)
CREATE POLICY "Anyone can view guilds"
  ON guilds FOR SELECT
  USING (true);

-- Only service role can insert (via create_guild function)
CREATE POLICY "Service role can insert guilds"
  ON guilds FOR INSERT
  WITH CHECK (false);  -- Blocked at RLS, use function

-- Leaders can update their guild settings
CREATE POLICY "Leaders can update own guild"
  ON guilds FOR UPDATE
  USING (
    leader_id IN (SELECT id FROM players WHERE user_id = auth.uid())
  );

-- No direct delete - use disband_guild function
CREATE POLICY "No direct guild deletion"
  ON guilds FOR DELETE
  USING (false);
```

2. **guild_members table RLS:**
```sql
ALTER TABLE guild_members ENABLE ROW LEVEL SECURITY;

-- Members can view their guild's roster
CREATE POLICY "Members can view guild roster"
  ON guild_members FOR SELECT
  USING (
    guild_id IN (
      SELECT guild_id FROM guild_members gm
      JOIN players p ON p.id = gm.player_id
      WHERE p.user_id = auth.uid()
    )
    OR
    -- Also allow viewing public guild rosters
    guild_id IN (SELECT id FROM guilds WHERE join_mode = 'open')
  );

-- No direct insert/update/delete - use functions
CREATE POLICY "No direct member insert"
  ON guild_members FOR INSERT
  WITH CHECK (false);

CREATE POLICY "No direct member update"
  ON guild_members FOR UPDATE
  USING (false);

CREATE POLICY "No direct member delete"
  ON guild_members FOR DELETE
  USING (false);
```

Note: All mutations go through SECURITY DEFINER functions to ensure atomicity and proper permission checks.
  </action>
  <verify>Verify RLS policies don't conflict with existing policies. Check that service role bypass works for functions.</verify>
  <done>RLS policies enable read access for guild discovery while protecting mutations behind SECURITY DEFINER functions.</done>
</task>

<task type="auto">
  <name>Task 3: Create atomic database functions</name>
  <files>supabase/migrations/022_guilds.sql</files>
  <action>
Append SECURITY DEFINER functions to the migration file:

1. **create_guild function:**
```sql
CREATE OR REPLACE FUNCTION create_guild(
  p_player_id UUID,
  p_name TEXT,
  p_tag TEXT,
  p_description TEXT DEFAULT NULL
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_guild_id UUID;
  v_left_guild_at TIMESTAMPTZ;
BEGIN
  -- Check player isn't already in a guild
  IF EXISTS (SELECT 1 FROM guild_members WHERE player_id = p_player_id) THEN
    RETURN json_build_object('success', false, 'error', 'Already in a guild');
  END IF;

  -- Check 24hr cooldown from leaving previous guild
  SELECT left_guild_at INTO v_left_guild_at FROM players WHERE id = p_player_id;
  IF v_left_guild_at IS NOT NULL AND v_left_guild_at > NOW() - INTERVAL '24 hours' THEN
    RETURN json_build_object('success', false, 'error', 'Must wait 24 hours after leaving a guild');
  END IF;

  -- Validate name format (additional server-side check)
  IF char_length(p_name) < 3 OR char_length(p_name) > 30 THEN
    RETURN json_build_object('success', false, 'error', 'Guild name must be 3-30 characters');
  END IF;
  IF NOT p_name ~ '^[a-zA-Z0-9 ]+$' THEN
    RETURN json_build_object('success', false, 'error', 'Guild name can only contain letters, numbers, and spaces');
  END IF;

  -- Validate tag format
  IF char_length(p_tag) < 2 OR char_length(p_tag) > 5 THEN
    RETURN json_build_object('success', false, 'error', 'Guild tag must be 2-5 characters');
  END IF;
  IF NOT UPPER(p_tag) ~ '^[A-Z0-9]+$' THEN
    RETURN json_build_object('success', false, 'error', 'Guild tag can only contain letters and numbers');
  END IF;

  -- Create guild (will fail on unique constraint if name/tag exists)
  BEGIN
    INSERT INTO guilds (name, tag, description, leader_id)
    VALUES (TRIM(p_name), UPPER(TRIM(p_tag)), NULLIF(TRIM(p_description), ''), p_player_id)
    RETURNING id INTO v_guild_id;
  EXCEPTION WHEN unique_violation THEN
    RETURN json_build_object('success', false, 'error', 'Guild name or tag already exists');
  END;

  -- Add leader as member (triggers sync_player_guild_id)
  INSERT INTO guild_members (guild_id, player_id, role)
  VALUES (v_guild_id, p_player_id, 'leader');

  -- Clear cooldown timestamp
  UPDATE players SET left_guild_at = NULL WHERE id = p_player_id;

  RETURN json_build_object('success', true, 'guild_id', v_guild_id);
END;
$$;
```

2. **join_guild function:**
```sql
CREATE OR REPLACE FUNCTION join_guild(
  p_player_id UUID,
  p_guild_id UUID
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_guild RECORD;
  v_left_guild_at TIMESTAMPTZ;
BEGIN
  -- Lock guild row to prevent race condition on member_count
  SELECT * INTO v_guild FROM guilds WHERE id = p_guild_id FOR UPDATE;

  IF v_guild IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Guild not found');
  END IF;

  -- Check join mode
  IF v_guild.join_mode != 'open' THEN
    RETURN json_build_object('success', false, 'error', 'Guild is not accepting new members');
  END IF;

  -- Check member cap
  IF v_guild.member_count >= v_guild.max_members THEN
    RETURN json_build_object('success', false, 'error', 'Guild is full');
  END IF;

  -- Check player isn't already in a guild
  IF EXISTS (SELECT 1 FROM guild_members WHERE player_id = p_player_id) THEN
    RETURN json_build_object('success', false, 'error', 'Already in a guild');
  END IF;

  -- Check 24hr cooldown
  SELECT left_guild_at INTO v_left_guild_at FROM players WHERE id = p_player_id;
  IF v_left_guild_at IS NOT NULL AND v_left_guild_at > NOW() - INTERVAL '24 hours' THEN
    RETURN json_build_object('success', false, 'error', 'Must wait 24 hours after leaving a guild');
  END IF;

  -- Add member
  INSERT INTO guild_members (guild_id, player_id, role)
  VALUES (p_guild_id, p_player_id, 'member');

  -- Update member count
  UPDATE guilds SET member_count = member_count + 1 WHERE id = p_guild_id;

  -- Clear cooldown timestamp
  UPDATE players SET left_guild_at = NULL WHERE id = p_player_id;

  RETURN json_build_object('success', true);
END;
$$;
```

3. **leave_guild function:**
```sql
CREATE OR REPLACE FUNCTION leave_guild(p_player_id UUID)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_member RECORD;
  v_member_count INT;
BEGIN
  -- Get member info with lock
  SELECT gm.*, g.id as g_id INTO v_member
  FROM guild_members gm
  JOIN guilds g ON g.id = gm.guild_id
  WHERE gm.player_id = p_player_id
  FOR UPDATE OF gm;

  IF v_member IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Not in a guild');
  END IF;

  -- Check if leader
  IF v_member.role = 'leader' THEN
    -- Count remaining members
    SELECT COUNT(*) INTO v_member_count FROM guild_members WHERE guild_id = v_member.guild_id;

    IF v_member_count > 1 THEN
      RETURN json_build_object('success', false, 'error', 'Leader must transfer leadership or disband guild before leaving');
    END IF;

    -- Last member - delete guild (cascade deletes member)
    DELETE FROM guilds WHERE id = v_member.guild_id;
    RETURN json_build_object('success', true, 'guild_disbanded', true);
  END IF;

  -- Remove member (triggers sync_player_guild_id which sets left_guild_at)
  DELETE FROM guild_members WHERE player_id = p_player_id;

  -- Update member count
  UPDATE guilds SET member_count = member_count - 1 WHERE id = v_member.guild_id;

  RETURN json_build_object('success', true);
END;
$$;
```
  </action>
  <verify>Review function logic for race conditions. Verify FOR UPDATE locking is used correctly. Check error messages are user-friendly.</verify>
  <done>Three atomic functions (create_guild, join_guild, leave_guild) handle guild lifecycle with proper locking, validation, and error handling.</done>
</task>

## Verification

- [ ] Migration file exists at `supabase/migrations/022_guilds.sql`
- [ ] File contains CREATE TYPE guild_role
- [ ] File contains CREATE TABLE guilds with all columns and constraints
- [ ] File contains CREATE TABLE guild_members with unique constraints
- [ ] File contains partial unique index for single leader
- [ ] File contains ALTER TABLE players for guild_id and left_guild_at
- [ ] File contains trigger for guild_id sync
- [ ] File contains RLS policies for both tables
- [ ] File contains create_guild, join_guild, leave_guild functions
- [ ] All functions use SECURITY DEFINER
- [ ] All functions use FOR UPDATE where needed for race condition prevention

## Success Criteria

Migration file is complete and ready to apply. When applied:
- Can create a guild via `SELECT create_guild(player_id, 'Name', 'TAG', 'Description')`
- Guild creation fails for duplicate names/tags
- Can join an open guild via `SELECT join_guild(player_id, guild_id)`
- Join fails when guild is full (50 members)
- Can leave guild via `SELECT leave_guild(player_id)`
- 24hr cooldown is enforced between leaving and joining
- Only one leader per guild (enforced by partial unique index)

## Output

After completion, create `.planning/phases/01-guild-foundation/01-01-SUMMARY.md`
