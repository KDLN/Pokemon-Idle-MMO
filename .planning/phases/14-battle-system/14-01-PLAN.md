---
phase: 14-battle-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/game-server/src/battle/battleManager.ts
  - apps/game-server/src/battle/index.ts
  - apps/game-server/src/types.ts
  - packages/shared/src/types/battle.ts
autonomous: true

must_haves:
  truths:
    - "Server can store active battle state keyed by player ID"
    - "Active battles track timeout with 30-second limit"
    - "Battle state includes current HP, turn number, and status"
  artifacts:
    - path: "apps/game-server/src/battle/battleManager.ts"
      provides: "ActiveBattle state management with timeout tracking"
      exports: ["BattleManager", "ActiveBattle"]
    - path: "apps/game-server/src/battle/index.ts"
      provides: "Barrel export for battle module"
      exports: ["BattleManager", "ActiveBattle"]
    - path: "packages/shared/src/types/battle.ts"
      provides: "Extended battle types for progressive protocol"
      contains: "BattleStatus"
  key_links:
    - from: "apps/game-server/src/battle/battleManager.ts"
      to: "apps/game-server/src/types.ts"
      via: "imports WildPokemon, Pokemon, PokemonSpecies"
      pattern: "import.*from.*types"
---

<objective>
Create server-side battle state management foundation for progressive turn revelation.

Purpose: Enable the server to track active battles per player with timeout handling, which is required before implementing progressive turn protocol.

Output: BattleManager class that stores ActiveBattle state keyed by player ID, with 30-second timeout tracking and cleanup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/intel/summary.md
@.planning/phases/14-battle-system/14-RESEARCH.md
@apps/game-server/src/types.ts
@packages/shared/src/types/battle.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add battle status types to shared package</name>
  <files>packages/shared/src/types/battle.ts</files>
  <action>
Add new types for progressive battle protocol to the existing battle.ts:

```typescript
// Battle status for progressive turns
export type BattleStatus = 'battling' | 'catching' | 'complete' | 'timeout'

// Server -> Client: Single turn data
export interface BattleTurnMessage {
  turn: BattleTurn
  battleStatus: 'ongoing' | 'player_win' | 'player_faint'
  playerHP: number
  wildHP: number
  canCatch: boolean  // true only after player wins
}

// Client -> Server: Request next turn
export interface RequestTurnPayload {
  battle_id: string
}

// Server -> Client: Catch result with animation data
export interface CatchResultMessage {
  shakeCount: number  // Always 3 for suspense
  success: boolean
  isNewPokedexEntry: boolean
  catchStrength: number  // For catch meter display
}
```

Keep all existing types (BattleTurn, BattleSequence, GymBattleMatchup). Add new types at the end of the file.
  </action>
  <verify>Run `npx tsc --noEmit -p packages/shared` to verify types compile</verify>
  <done>BattleStatus, BattleTurnMessage, RequestTurnPayload, and CatchResultMessage types exist and compile</done>
</task>

<task type="auto">
  <name>Task 2: Create BattleManager class for active battle state</name>
  <files>apps/game-server/src/battle/battleManager.ts, apps/game-server/src/battle/index.ts</files>
  <action>
Create new file `apps/game-server/src/battle/battleManager.ts`:

```typescript
import type { Pokemon, PokemonSpecies, WildPokemon } from '../types.js'
import type { BattleStatus } from '@pokemon-idle/shared'

export interface ActiveBattle {
  playerId: string
  wildPokemon: WildPokemon
  leadPokemon: Pokemon
  leadSpecies: PokemonSpecies
  playerHP: number
  wildHP: number
  playerMaxHP: number
  wildMaxHP: number
  turnNumber: number
  startedAt: number       // Date.now() when battle started
  lastActivity: number    // Date.now() of last client activity
  status: BattleStatus
  playerFirst: boolean    // Determined by speed comparison
}

const BATTLE_TIMEOUT_MS = 30_000  // 30 seconds per requirement BATTLE-05

export class BattleManager {
  private activeBattles: Map<string, ActiveBattle> = new Map()
  private cleanupInterval: NodeJS.Timeout | null = null

  constructor() {
    // Start cleanup interval to check for timed-out battles every 5 seconds
    this.cleanupInterval = setInterval(() => this.cleanupTimedOutBattles(), 5000)
  }

  stop(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval)
      this.cleanupInterval = null
    }
  }

  // Start a new battle for a player
  startBattle(
    playerId: string,
    wildPokemon: WildPokemon,
    leadPokemon: Pokemon,
    leadSpecies: PokemonSpecies
  ): ActiveBattle {
    // Clean up any existing battle for this player
    this.activeBattles.delete(playerId)

    const now = Date.now()
    const playerFirst = leadPokemon.stat_speed >= wildPokemon.stat_speed

    const battle: ActiveBattle = {
      playerId,
      wildPokemon,
      leadPokemon,
      leadSpecies,
      playerHP: leadPokemon.current_hp,
      wildHP: wildPokemon.max_hp,
      playerMaxHP: leadPokemon.max_hp,
      wildMaxHP: wildPokemon.max_hp,
      turnNumber: 0,
      startedAt: now,
      lastActivity: now,
      status: 'battling',
      playerFirst
    }

    this.activeBattles.set(playerId, battle)
    return battle
  }

  // Get active battle for a player
  getBattle(playerId: string): ActiveBattle | undefined {
    return this.activeBattles.get(playerId)
  }

  // Update battle state after a turn
  updateBattle(playerId: string, updates: Partial<ActiveBattle>): ActiveBattle | undefined {
    const battle = this.activeBattles.get(playerId)
    if (!battle) return undefined

    Object.assign(battle, updates, { lastActivity: Date.now() })
    return battle
  }

  // Record client activity (prevents timeout)
  recordActivity(playerId: string): void {
    const battle = this.activeBattles.get(playerId)
    if (battle) {
      battle.lastActivity = Date.now()
    }
  }

  // End a battle (win, lose, or timeout)
  endBattle(playerId: string): ActiveBattle | undefined {
    const battle = this.activeBattles.get(playerId)
    this.activeBattles.delete(playerId)
    return battle
  }

  // Check if player has active battle
  hasBattle(playerId: string): boolean {
    return this.activeBattles.has(playerId)
  }

  // Get all active battles (for debugging/monitoring)
  getAllBattles(): Map<string, ActiveBattle> {
    return this.activeBattles
  }

  // Clean up battles that have timed out
  private cleanupTimedOutBattles(): void {
    const now = Date.now()
    for (const [playerId, battle] of this.activeBattles) {
      if (now - battle.lastActivity > BATTLE_TIMEOUT_MS) {
        console.log(`[Battle] Timeout for player ${playerId} - auto-resolving`)
        battle.status = 'timeout'
        // Battle will be auto-resolved in processTick when client reconnects
        // or cleaned up on next cleanup cycle if still stale
      }
    }
  }
}
```

Create barrel export `apps/game-server/src/battle/index.ts`:

```typescript
export { BattleManager, type ActiveBattle } from './battleManager.js'
```
  </action>
  <verify>Run `cd apps/game-server && npx tsc --noEmit` to verify compilation</verify>
  <done>BattleManager class exists with startBattle, getBattle, updateBattle, endBattle, and timeout cleanup</done>
</task>

<task type="auto">
  <name>Task 3: Add BattleManager to hub.ts (initialize only)</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
Add BattleManager to GameHub class. This task only initializes it - the message handlers will be added in Plan 02.

1. Add import at top of file (after other imports):
```typescript
import { BattleManager } from './battle/index.js'
```

2. Add private property in GameHub class (after other private properties like `private tradeReadyStates`):
```typescript
private battleManager: BattleManager = new BattleManager()
```

3. In the `stop()` method, add cleanup before `this.wss.close()`:
```typescript
this.battleManager.stop()
```

Do NOT add message handlers or modify processTicks yet - that's Plan 02's scope.
  </action>
  <verify>Run `cd apps/game-server && npx tsc --noEmit` and verify no compilation errors</verify>
  <done>BattleManager instance created in GameHub with proper cleanup on stop()</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/shared` - Shared types compile
2. `cd apps/game-server && npx tsc --noEmit` - Game server compiles
3. Verify BattleManager has all required methods: startBattle, getBattle, updateBattle, endBattle, hasBattle, recordActivity, stop
4. Verify ActiveBattle interface includes: playerId, wildPokemon, leadPokemon, leadSpecies, playerHP, wildHP, turnNumber, startedAt, lastActivity, status, playerFirst
</verification>

<success_criteria>
- BattleManager class created with in-memory battle state storage
- 30-second timeout tracking implemented with cleanup interval
- ActiveBattle interface captures all state needed for progressive turns
- Shared types extended with BattleTurnMessage and CatchResultMessage
- Game server compiles without errors
- BattleManager initialized in GameHub
</success_criteria>

<output>
After completion, create `.planning/phases/14-battle-system/14-01-SUMMARY.md`
</output>
