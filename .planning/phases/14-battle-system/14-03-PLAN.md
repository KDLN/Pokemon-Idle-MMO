---
phase: 14-battle-system
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - apps/web/src/hooks/useBattleAnimation.ts
  - apps/web/src/lib/ws/gameSocket.ts
  - apps/web/src/stores/gameStore.ts
  - packages/shared/src/types/battle.ts
autonomous: true

must_haves:
  truths:
    - "Client requests next turn from server after animation completes"
    - "Player sees each turn animate before knowing the next outcome"
    - "Battle animation hook handles server-driven turns"
  artifacts:
    - path: "apps/web/src/hooks/useBattleAnimation.ts"
      provides: "Server-driven battle animation state machine"
      exports: ["useBattleAnimation"]
    - path: "apps/web/src/lib/ws/gameSocket.ts"
      provides: "Message handlers for progressive battle protocol"
      contains: "encounter_start"
  key_links:
    - from: "apps/web/src/hooks/useBattleAnimation.ts"
      to: "apps/web/src/lib/ws/gameSocket.ts"
      via: "gameSocket.requestTurn()"
      pattern: "gameSocket\\.requestTurn"
    - from: "apps/web/src/lib/ws/gameSocket.ts"
      to: "apps/web/src/stores/gameStore.ts"
      via: "useGameStore handlers"
      pattern: "useGameStore\\.getState\\(\\)"
---

<objective>
Update the client to handle server-driven progressive battle turns.

Purpose: Transform the battle animation from self-contained (all turns pre-known) to server-paced (each turn requested after animation completes). This creates genuine uncertainty since the player doesn't know the next turn's outcome.

Output: Client requests turns from server, animates each turn, then requests the next. Battle outcome is revealed progressively.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-battle-system/14-RESEARCH.md
@.planning/phases/14-battle-system/14-02-SUMMARY.md
@apps/web/src/hooks/useBattleAnimation.ts
@apps/web/src/lib/ws/gameSocket.ts
@apps/web/src/stores/gameStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add progressive battle handlers to gameSocket</name>
  <files>apps/web/src/lib/ws/gameSocket.ts</files>
  <action>
Add message handlers and methods for progressive battle protocol.

1. Add handler registrations in constructor (after existing handlers):
```typescript
this.handlers.set('encounter_start', this.handleEncounterStart)
this.handlers.set('battle_turn', this.handleBattleTurn)
this.handlers.set('catch_result', this.handleCatchResult)
this.handlers.set('catch_complete', this.handleCatchComplete)
this.handlers.set('battle_summary', this.handleBattleSummary)
```

2. Add methods for sending battle requests:
```typescript
// Request next battle turn from server
requestTurn() {
  this.send('request_turn', {})
}

// Attempt to catch the wild Pokemon
attemptCatch(ballType: 'pokeball' | 'great_ball') {
  this.send('attempt_catch', { ball_type: ballType })
}
```

3. Add handler methods:
```typescript
private handleEncounterStart = (payload: unknown) => {
  const data = payload as {
    wild_pokemon: WildPokemon
    lead_pokemon: {
      id: string
      name: string
      level: number
      current_hp: number
      max_hp: number
      species_id: number
      is_shiny: boolean
    }
    player_first: boolean
  }

  const store = useGameStore.getState()
  store.setActiveBattle({
    wildPokemon: data.wild_pokemon,
    leadPokemon: data.lead_pokemon,
    playerFirst: data.player_first,
    status: 'intro',
    currentTurn: null,
    playerHP: data.lead_pokemon.current_hp,
    wildHP: data.wild_pokemon.max_hp,
    playerMaxHP: data.lead_pokemon.max_hp,
    wildMaxHP: data.wild_pokemon.max_hp
  })
}

private handleBattleTurn = (payload: unknown) => {
  const data = payload as {
    turn: BattleTurn
    battleStatus: 'ongoing' | 'player_win' | 'player_faint'
    playerHP: number
    wildHP: number
    canCatch: boolean
  }

  const store = useGameStore.getState()
  store.setBattleTurn({
    turn: data.turn,
    battleStatus: data.battleStatus,
    playerHP: data.playerHP,
    wildHP: data.wildHP,
    canCatch: data.canCatch
  })
}

private handleCatchResult = (payload: unknown) => {
  const data = payload as {
    shakeCount: number
    success: boolean
    isNewPokedexEntry: boolean
    catchStrength: number
    ball_type: string
    pokeballs: number
    great_balls: number
  }

  const store = useGameStore.getState()
  store.setCatchResult(data)

  // Update inventory
  store.setInventory({
    ...store.inventory,
    pokeball: data.pokeballs,
    great_ball: data.great_balls
  })
  store.setPokeballs(data.pokeballs)
}

private handleCatchComplete = (payload: unknown) => {
  const data = payload as {
    caught_pokemon: Pokemon
    xp_earned: number
    is_new_pokedex_entry: boolean
  }

  const store = useGameStore.getState()
  store.setCatchComplete(data)

  // Add caught Pokemon to box
  store.addToBox(data.caught_pokemon)

  // Apply XP to lead Pokemon
  if (data.xp_earned > 0) {
    store.applyXPGains({ [store.party[0]?.id || '']: data.xp_earned })
  }
}

private handleBattleSummary = (payload: unknown) => {
  const data = payload as {
    outcome: 'timeout' | 'win' | 'lose'
    message: string
  }

  const store = useGameStore.getState()
  store.setBattleSummary(data)
}
```

4. Add import for BattleTurn type at top:
```typescript
import type { BattleTurn } from '@pokemon-idle/shared'
```

Note: The WildPokemon and Pokemon types should already be imported. If not, add them.
  </action>
  <verify>Run `cd apps/web && npx tsc --noEmit` to verify compilation</verify>
  <done>gameSocket handles encounter_start, battle_turn, catch_result, catch_complete, battle_summary messages</done>
</task>

<task type="auto">
  <name>Task 2: Add battle state to gameStore</name>
  <files>apps/web/src/stores/gameStore.ts</files>
  <action>
Add state and actions for progressive battle management.

1. Add new state types (add to GameState interface):
```typescript
// Progressive battle state
activeBattle: {
  wildPokemon: WildPokemon
  leadPokemon: {
    id: string
    name: string
    level: number
    current_hp: number
    max_hp: number
    species_id: number
    is_shiny: boolean
  }
  playerFirst: boolean
  status: 'intro' | 'battling' | 'catching' | 'complete' | 'summary'
  currentTurn: BattleTurn | null
  playerHP: number
  wildHP: number
  playerMaxHP: number
  wildMaxHP: number
  canCatch: boolean
  catchResult: {
    shakeCount: number
    success: boolean
    isNewPokedexEntry: boolean
    catchStrength: number
  } | null
  catchComplete: {
    caught_pokemon: Pokemon
    xp_earned: number
    is_new_pokedex_entry: boolean
  } | null
  battleSummary: {
    outcome: 'timeout' | 'win' | 'lose'
    message: string
  } | null
} | null
```

2. Add initial state (in the create function):
```typescript
activeBattle: null,
```

3. Add actions (in the create function):
```typescript
setActiveBattle: (battle) => set({ activeBattle: battle ? { ...battle, canCatch: false, catchResult: null, catchComplete: null, battleSummary: null } : null }),

setBattleTurn: (data) => set((state) => ({
  activeBattle: state.activeBattle ? {
    ...state.activeBattle,
    status: data.battleStatus === 'ongoing' ? 'battling' : (data.canCatch ? 'catching' : 'complete'),
    currentTurn: data.turn,
    playerHP: data.playerHP,
    wildHP: data.wildHP,
    canCatch: data.canCatch
  } : null
})),

setCatchResult: (data) => set((state) => ({
  activeBattle: state.activeBattle ? {
    ...state.activeBattle,
    status: 'catching',
    catchResult: {
      shakeCount: data.shakeCount,
      success: data.success,
      isNewPokedexEntry: data.isNewPokedexEntry,
      catchStrength: data.catchStrength
    }
  } : null
})),

setCatchComplete: (data) => set((state) => ({
  activeBattle: state.activeBattle ? {
    ...state.activeBattle,
    status: 'complete',
    catchComplete: data
  } : null
})),

setBattleSummary: (data) => set((state) => ({
  activeBattle: state.activeBattle ? {
    ...state.activeBattle,
    status: 'summary',
    battleSummary: data
  } : null
})),

clearActiveBattle: () => set({ activeBattle: null }),
```

4. Import BattleTurn type at top of file:
```typescript
import type { BattleTurn } from '@pokemon-idle/shared'
```
  </action>
  <verify>Run `cd apps/web && npx tsc --noEmit` to verify compilation</verify>
  <done>gameStore has activeBattle state with setActiveBattle, setBattleTurn, setCatchResult, setCatchComplete, setBattleSummary, clearActiveBattle actions</done>
</task>

<task type="auto">
  <name>Task 3: Update useBattleAnimation for server-driven mode</name>
  <files>apps/web/src/hooks/useBattleAnimation.ts</files>
  <action>
Refactor useBattleAnimation to work with server-driven progressive turns instead of self-contained animation.

Key changes:
1. Use activeBattle from store instead of encounter prop
2. Request next turn from server after animation completes
3. Wait for server response before advancing to next turn

Replace the entire file content:

```typescript
'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { useGameStore } from '@/stores/gameStore'
import { gameSocket } from '@/lib/ws/gameSocket'
import type { BattleTurn } from '@pokemon-idle/shared'

// Compressed phase durations to fit 800ms budget (BATTLE-07)
const PHASE_DURATIONS = {
  appear: 600,
  battle_intro: 800,
  turn_active: 500,      // Attack + damage shown together
  battle_end: 1000,
  catch_throw: 500,
  catch_shake: 600,      // Per shake (3 shakes = 1800ms total)
  catch_result: 1000,
  rewards: 800,
  fade_out: 400,
  summary: 2000
}

export type BattlePhase =
  | 'idle'
  | 'appear'
  | 'battle_intro'
  | 'waiting_for_turn'
  | 'turn_active'
  | 'battle_end'
  | 'waiting_for_catch'
  | 'catch_throw'
  | 'catch_shake'
  | 'catch_result'
  | 'rewards'
  | 'fade_out'
  | 'summary'

export interface BattleAnimationState {
  phase: BattlePhase
  currentTurn: BattleTurn | null
  playerHP: number
  wildHP: number
  playerMaxHP: number
  wildMaxHP: number
  currentShake: number
  totalShakes: number
  messageText: string
  showDamageNumber: boolean
  damageAmount: number
  damageTarget: 'player' | 'wild'
  isCritical: boolean
  isAnimating: boolean
  canCatch: boolean
  catchSuccess: boolean | null
  isNewPokedexEntry: boolean
}

const EFFECTIVENESS_MESSAGES = {
  super: "It's super effective!",
  not_very: "It's not very effective...",
  immune: "It has no effect!",
  neutral: ''
} as const

function describeTurn(turn: BattleTurn): string {
  const effectiveness = EFFECTIVENESS_MESSAGES[turn.effectiveness]
  return [`${turn.attacker_name} used ${turn.move_name}!`, effectiveness].filter(Boolean).join(' ')
}

export function useBattleAnimation(onComplete: () => void) {
  const activeBattle = useGameStore((state) => state.activeBattle)
  const clearActiveBattle = useGameStore((state) => state.clearActiveBattle)

  const [state, setState] = useState<BattleAnimationState>({
    phase: 'idle',
    currentTurn: null,
    playerHP: 0,
    wildHP: 0,
    playerMaxHP: 0,
    wildMaxHP: 0,
    currentShake: 0,
    totalShakes: 3,
    messageText: '',
    showDamageNumber: false,
    damageAmount: 0,
    damageTarget: 'wild',
    isCritical: false,
    isAnimating: false,
    canCatch: false,
    catchSuccess: null,
    isNewPokedexEntry: false
  })

  const timeoutRef = useRef<NodeJS.Timeout | null>(null)
  const battleRef = useRef(activeBattle)

  const clearPendingTimeout = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
      timeoutRef.current = null
    }
  }, [])

  const schedulePhase = useCallback((
    nextPhase: BattlePhase,
    delay: number,
    updates?: Partial<BattleAnimationState>
  ) => {
    clearPendingTimeout()
    timeoutRef.current = setTimeout(() => {
      setState(prev => ({ ...prev, phase: nextPhase, ...updates }))
    }, delay)
  }, [clearPendingTimeout])

  // Handle new battle starting
  useEffect(() => {
    if (activeBattle && activeBattle !== battleRef.current && activeBattle.status === 'intro') {
      battleRef.current = activeBattle
      clearPendingTimeout()

      setState({
        phase: 'appear',
        currentTurn: null,
        playerHP: activeBattle.playerHP,
        wildHP: activeBattle.wildHP,
        playerMaxHP: activeBattle.playerMaxHP,
        wildMaxHP: activeBattle.wildMaxHP,
        currentShake: 0,
        totalShakes: 3,
        messageText: `Wild ${activeBattle.wildPokemon.species.name} appeared!`,
        showDamageNumber: false,
        damageAmount: 0,
        damageTarget: 'wild',
        isCritical: false,
        isAnimating: true,
        canCatch: false,
        catchSuccess: null,
        isNewPokedexEntry: false
      })
    }

    // Update battleRef when battle changes
    battleRef.current = activeBattle
  }, [activeBattle, clearPendingTimeout])

  // Handle turn received from server
  useEffect(() => {
    if (!activeBattle?.currentTurn || state.phase !== 'waiting_for_turn') return

    const turn = activeBattle.currentTurn
    const damageTarget = turn.attacker === 'player' ? 'wild' : 'player'

    setState(prev => ({
      ...prev,
      phase: 'turn_active',
      currentTurn: turn,
      messageText: describeTurn(turn),
      showDamageNumber: true,
      damageAmount: turn.damage_dealt,
      damageTarget,
      isCritical: turn.is_critical,
      playerHP: activeBattle.playerHP,
      wildHP: activeBattle.wildHP,
      canCatch: activeBattle.canCatch
    }))
  }, [activeBattle?.currentTurn, state.phase])

  // Handle catch result from server
  useEffect(() => {
    if (!activeBattle?.catchResult || state.phase !== 'waiting_for_catch') return

    setState(prev => ({
      ...prev,
      phase: 'catch_throw',
      totalShakes: activeBattle.catchResult!.shakeCount,
      catchSuccess: activeBattle.catchResult!.success,
      isNewPokedexEntry: activeBattle.catchResult!.isNewPokedexEntry
    }))
  }, [activeBattle?.catchResult, state.phase])

  // State machine transitions
  useEffect(() => {
    if (!activeBattle || state.phase === 'idle') return

    switch (state.phase) {
      case 'appear':
        schedulePhase('battle_intro', PHASE_DURATIONS.appear)
        break

      case 'battle_intro':
        // Request first turn from server
        schedulePhase('waiting_for_turn', PHASE_DURATIONS.battle_intro)
        setTimeout(() => gameSocket.requestTurn(), PHASE_DURATIONS.battle_intro)
        break

      case 'turn_active':
        // After turn animation, check battle status
        const battleStatus = activeBattle.canCatch ? 'player_win' :
                            (activeBattle.playerHP <= 0 ? 'player_faint' : 'ongoing')

        if (battleStatus === 'ongoing') {
          // Request next turn
          schedulePhase('waiting_for_turn', PHASE_DURATIONS.turn_active, {
            showDamageNumber: false
          })
          setTimeout(() => gameSocket.requestTurn(), PHASE_DURATIONS.turn_active)
        } else if (battleStatus === 'player_win') {
          // Battle won, show end then wait for catch
          schedulePhase('battle_end', PHASE_DURATIONS.turn_active, {
            showDamageNumber: false,
            messageText: `${activeBattle.wildPokemon.species.name} fainted!`
          })
        } else {
          // Player fainted
          schedulePhase('battle_end', PHASE_DURATIONS.turn_active, {
            showDamageNumber: false,
            messageText: `${activeBattle.leadPokemon.name} fainted!`
          })
        }
        break

      case 'battle_end':
        if (state.canCatch) {
          // Auto-attempt catch with best available ball
          schedulePhase('waiting_for_catch', PHASE_DURATIONS.battle_end, {
            messageText: ''
          })
          // Determine ball type (prefer great balls if available)
          const inventory = useGameStore.getState().inventory
          const ballType = (inventory.great_ball || 0) > 0 ? 'great_ball' : 'pokeball'
          setTimeout(() => gameSocket.attemptCatch(ballType), PHASE_DURATIONS.battle_end)
        } else {
          // No catch - fade out
          schedulePhase('fade_out', PHASE_DURATIONS.battle_end)
        }
        break

      case 'catch_throw':
        schedulePhase('catch_shake', PHASE_DURATIONS.catch_throw, {
          currentShake: 1
        })
        break

      case 'catch_shake':
        if (state.currentShake < state.totalShakes) {
          schedulePhase('catch_shake', PHASE_DURATIONS.catch_shake, {
            currentShake: state.currentShake + 1
          })
        } else {
          schedulePhase('catch_result', PHASE_DURATIONS.catch_shake, {
            messageText: state.catchSuccess ? 'Gotcha!' : 'Oh no! It broke free!'
          })
        }
        break

      case 'catch_result':
        if (state.catchSuccess) {
          schedulePhase('rewards', PHASE_DURATIONS.catch_result)
        } else {
          schedulePhase('fade_out', PHASE_DURATIONS.catch_result)
        }
        break

      case 'rewards':
        schedulePhase('fade_out', PHASE_DURATIONS.rewards)
        break

      case 'fade_out':
        timeoutRef.current = setTimeout(() => {
          setState(prev => ({ ...prev, phase: 'idle', isAnimating: false }))
          clearActiveBattle()
          onComplete()
        }, PHASE_DURATIONS.fade_out)
        break

      case 'summary':
        // Battle summary from timeout/reconnect
        schedulePhase('fade_out', PHASE_DURATIONS.summary, {
          messageText: activeBattle.battleSummary?.message || ''
        })
        break
    }
  }, [state.phase, state.currentShake, state.canCatch, state.catchSuccess, state.totalShakes, activeBattle, schedulePhase, clearActiveBattle, onComplete])

  // Handle battle summary (timeout/reconnect)
  useEffect(() => {
    if (activeBattle?.battleSummary && state.phase !== 'summary') {
      setState(prev => ({
        ...prev,
        phase: 'summary',
        messageText: activeBattle.battleSummary!.message,
        isAnimating: true
      }))
    }
  }, [activeBattle?.battleSummary, state.phase])

  // Cleanup on unmount
  useEffect(() => {
    return () => clearPendingTimeout()
  }, [clearPendingTimeout])

  // Calculate HP percentages
  const playerHPPercent = state.playerMaxHP > 0 ? (state.playerHP / state.playerMaxHP) * 100 : 100
  const wildHPPercent = state.wildMaxHP > 0 ? (state.wildHP / state.wildMaxHP) * 100 : 100

  return {
    ...state,
    playerHPPercent,
    wildHPPercent,
    isPhase: (phase: BattlePhase) => state.phase === phase,
    isInBattle: state.phase === 'turn_active' || state.phase === 'waiting_for_turn',
    isInCatch: ['catch_throw', 'catch_shake', 'catch_result', 'waiting_for_catch'].includes(state.phase),
    wildPokemon: activeBattle?.wildPokemon || null,
    leadPokemon: activeBattle?.leadPokemon || null
  }
}
```
  </action>
  <verify>
1. Run `cd apps/web && npx tsc --noEmit`
2. Verify hook uses gameSocket.requestTurn() after animations
3. Verify waiting_for_turn phase exists
4. Verify phase durations fit 800ms budget
  </verify>
  <done>useBattleAnimation requests turns from server and waits for response before showing next turn</done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` - Web app compiles
2. Verify gameSocket has requestTurn() and attemptCatch() methods
3. Verify gameStore has activeBattle state
4. Verify useBattleAnimation has waiting_for_turn phase
5. Verify PHASE_DURATIONS.turn_active is 500ms (under 800ms budget)
</verification>

<success_criteria>
- Client requests turns from server using requestTurn()
- Battle animation pauses in waiting_for_turn until server responds
- Each turn animates before player knows next outcome
- Catch attempt sent to server with attemptCatch()
- Catch animation plays with 3 shakes for suspense
- Battle summary displayed on reconnect after timeout
- Turn animation completes within 800ms (500ms turn_active)
</success_criteria>

<output>
After completion, create `.planning/phases/14-battle-system/14-03-SUMMARY.md`
</output>
