---
phase: 14-battle-system
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - apps/game-server/src/battle/turnCalculator.ts
  - apps/game-server/src/battle/index.ts
  - apps/game-server/src/hub.ts
  - apps/game-server/src/types.ts
autonomous: true

must_haves:
  truths:
    - "Server calculates one turn at a time (not pre-computed bulk)"
    - "Client requests next turn after animation completes"
    - "Battle continues server-side if client disconnects"
    - "Reconnected clients receive battle summary if battle timed out"
  artifacts:
    - path: "apps/game-server/src/battle/turnCalculator.ts"
      provides: "Single-turn calculation extracted from game.ts"
      exports: ["calculateSingleTurn"]
    - path: "apps/game-server/src/hub.ts"
      provides: "Message handlers for progressive battle protocol"
      contains: "request_turn"
  key_links:
    - from: "apps/game-server/src/hub.ts"
      to: "apps/game-server/src/battle/battleManager.ts"
      via: "battleManager.startBattle, updateBattle, endBattle"
      pattern: "this\\.battleManager\\."
    - from: "apps/game-server/src/hub.ts"
      to: "apps/game-server/src/battle/turnCalculator.ts"
      via: "calculateSingleTurn import"
      pattern: "calculateSingleTurn"
---

<objective>
Implement progressive turn calculation and request/response protocol for server-authoritative battles.

Purpose: Replace bulk battle_sequence with turn-by-turn calculation where the client must request each turn. This creates genuine uncertainty since the next turn's outcome is unknown until requested.

Output: Server handles `request_turn` messages and responds with single `battle_turn` messages, calculating each turn only when requested.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-battle-system/14-RESEARCH.md
@.planning/phases/14-battle-system/14-01-SUMMARY.md
@apps/game-server/src/game.ts
@apps/game-server/src/hub.ts
@apps/game-server/src/battle/battleManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract single-turn calculation from game.ts</name>
  <files>apps/game-server/src/battle/turnCalculator.ts, apps/game-server/src/battle/index.ts</files>
  <action>
Create `apps/game-server/src/battle/turnCalculator.ts` that calculates ONE turn at a time:

```typescript
import type { Pokemon, PokemonSpecies, WildPokemon, BattleTurn, Move } from '../types.js'
import { getTypeEffectiveness, calculateDamage } from '../game.js'
import type { ActiveBattle } from './battleManager.js'

// Type effectiveness category
function getEffectivenessCategory(multiplier: number): 'super' | 'neutral' | 'not_very' | 'immune' {
  if (multiplier === 0) return 'immune'
  if (multiplier >= 2) return 'super'
  if (multiplier < 1) return 'not_very'
  return 'neutral'
}

// Move selection (simplified from game.ts - uses first type-matched move)
function selectMove(attackerSpecies: PokemonSpecies, defenderType1: string, defenderType2: string | null): Move {
  const TYPE_MOVE_POOL: Record<string, Move> = {
    NORMAL: { name: 'Tackle', type: 'Normal', power: 40, accuracy: 0.95 },
    FIRE: { name: 'Ember', type: 'Fire', power: 40, accuracy: 1 },
    WATER: { name: 'Water Gun', type: 'Water', power: 45, accuracy: 0.95 },
    GRASS: { name: 'Vine Whip', type: 'Grass', power: 45, accuracy: 0.95 },
    ELECTRIC: { name: 'Spark', type: 'Electric', power: 65, accuracy: 0.9 },
    FLYING: { name: 'Peck', type: 'Flying', power: 35, accuracy: 1 },
    BUG: { name: 'Bug Bite', type: 'Bug', power: 55, accuracy: 0.9 },
    ROCK: { name: 'Rock Throw', type: 'Rock', power: 50, accuracy: 0.9 },
    POISON: { name: 'Poison Sting', type: 'Poison', power: 40, accuracy: 1 },
  }

  const typeKey = attackerSpecies.type1?.toUpperCase() ?? 'NORMAL'
  return TYPE_MOVE_POOL[typeKey] || TYPE_MOVE_POOL.NORMAL
}

export interface TurnResult {
  turn: BattleTurn
  newPlayerHP: number
  newWildHP: number
  battleEnded: boolean
  playerWon: boolean
}

/**
 * Calculate a single battle turn.
 * This is the core function for progressive turn revelation.
 * Called once per client request_turn message.
 */
export function calculateSingleTurn(battle: ActiveBattle): TurnResult {
  const {
    leadPokemon, leadSpecies, wildPokemon,
    playerHP, wildHP, playerMaxHP, wildMaxHP,
    turnNumber, playerFirst
  } = battle

  // Determine who attacks this turn based on turn parity and speed
  const isEvenTurn = turnNumber % 2 === 0
  const playerAttacks = isEvenTurn === playerFirst

  let newPlayerHP = playerHP
  let newWildHP = wildHP
  let turn: BattleTurn

  if (playerAttacks) {
    // Player attacks wild
    const move = selectMove(leadSpecies, wildPokemon.species.type1, wildPokemon.species.type2)
    const typeMultiplier = getTypeEffectiveness(
      leadSpecies.type1,
      wildPokemon.species.type1,
      wildPokemon.species.type2
    )
    const attackStat = Math.max(leadPokemon.stat_attack, leadPokemon.stat_sp_attack)
    const defenseStat = Math.max(wildPokemon.stat_defense, wildPokemon.stat_sp_defense)

    const { damage, isCritical } = calculateDamage(
      leadPokemon.level,
      attackStat,
      defenseStat,
      typeMultiplier,
      move.power
    )

    newWildHP = Math.max(0, wildHP - damage)

    turn = {
      turn_number: turnNumber,
      attacker: 'player',
      attacker_name: leadSpecies.name,
      defender_name: wildPokemon.species.name,
      damage_dealt: damage,
      is_critical: isCritical,
      effectiveness: getEffectivenessCategory(typeMultiplier),
      attacker_hp_after: playerHP,
      defender_hp_after: newWildHP,
      attacker_max_hp: playerMaxHP,
      defender_max_hp: wildMaxHP,
      move_name: move.name,
      move_type: move.type
    }
  } else {
    // Wild attacks player
    const move = selectMove(wildPokemon.species, leadSpecies.type1, leadSpecies.type2)
    const typeMultiplier = getTypeEffectiveness(
      wildPokemon.species.type1,
      leadSpecies.type1,
      leadSpecies.type2
    )
    const attackStat = Math.max(wildPokemon.stat_attack, wildPokemon.stat_sp_attack)
    const defenseStat = Math.max(leadPokemon.stat_defense, leadPokemon.stat_sp_defense)

    const { damage, isCritical } = calculateDamage(
      wildPokemon.level,
      attackStat,
      defenseStat,
      typeMultiplier,
      move.power
    )

    newPlayerHP = Math.max(0, playerHP - damage)

    turn = {
      turn_number: turnNumber,
      attacker: 'wild',
      attacker_name: wildPokemon.species.name,
      defender_name: leadSpecies.name,
      damage_dealt: damage,
      is_critical: isCritical,
      effectiveness: getEffectivenessCategory(typeMultiplier),
      attacker_hp_after: wildHP,
      defender_hp_after: newPlayerHP,
      attacker_max_hp: wildMaxHP,
      defender_max_hp: playerMaxHP,
      move_name: move.name,
      move_type: move.type
    }
  }

  const battleEnded = newPlayerHP <= 0 || newWildHP <= 0
  const playerWon = newWildHP <= 0

  return { turn, newPlayerHP, newWildHP, battleEnded, playerWon }
}
```

Update barrel export in `apps/game-server/src/battle/index.ts`:
```typescript
export { BattleManager, type ActiveBattle } from './battleManager.js'
export { calculateSingleTurn, type TurnResult } from './turnCalculator.js'
```
  </action>
  <verify>Run `cd apps/game-server && npx tsc --noEmit` to verify compilation</verify>
  <done>calculateSingleTurn function exists and computes one turn from ActiveBattle state</done>
</task>

<task type="auto">
  <name>Task 2: Add battle message types to types.ts</name>
  <files>apps/game-server/src/types.ts</files>
  <action>
Add payload types for the progressive battle protocol to `apps/game-server/src/types.ts`.

Find the section with other payload types (search for `interface.*Payload` pattern) and add:

```typescript
// Progressive battle payloads
export interface StartBattlePayload {
  // Empty - battle starts automatically from encounter
}

export interface RequestTurnPayload {
  // Empty - server knows which battle from player session
}

export interface AttemptCatchPayload {
  ball_type: BallType
}
```

Note: These types enable type-safe message handling in hub.ts.
  </action>
  <verify>Run `cd apps/game-server && npx tsc --noEmit` to verify types compile</verify>
  <done>Payload types exist for StartBattle, RequestTurn, and AttemptCatch messages</done>
</task>

<task type="auto">
  <name>Task 3: Add request_turn handler with handleRequestTurn method</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
Add the request_turn message handler and its implementation method to GameHub.

1. Add import at top of file (near other battle imports):
```typescript
import { calculateSingleTurn } from './battle/index.js'
```

2. Find the handleMessage switch statement (search for `case 'get_state':`) and add after it:
```typescript
case 'request_turn':
  this.handleRequestTurn(client)
  break
```

3. Add handler method to GameHub class (after handleMessage method):
```typescript
private handleRequestTurn(client: Client) {
  if (!client.session) return
  const playerId = client.session.player.id

  const battle = this.battleManager.getBattle(playerId)
  if (!battle) {
    this.sendToClient(client.ws, 'error', { message: 'No active battle' })
    return
  }

  // Check for timeout
  if (battle.status === 'timeout') {
    // Battle timed out - send summary and clean up
    const summary = this.resolveBattleSummary(battle)
    this.battleManager.endBattle(playerId)
    this.sendToClient(client.ws, 'battle_summary', summary)
    return
  }

  // Calculate next turn
  const result = calculateSingleTurn(battle)

  // Update battle state
  this.battleManager.updateBattle(playerId, {
    playerHP: result.newPlayerHP,
    wildHP: result.newWildHP,
    turnNumber: battle.turnNumber + 1,
    status: result.battleEnded ? (result.playerWon ? 'catching' : 'complete') : 'battling'
  })

  // If player's Pokemon fainted, update HP in session
  if (result.newPlayerHP <= 0 && client.session.party[0]) {
    client.session.party[0].current_hp = 0
  }

  // Send turn to client
  this.sendToClient(client.ws, 'battle_turn', {
    turn: result.turn,
    battleStatus: result.battleEnded ? (result.playerWon ? 'player_win' : 'player_faint') : 'ongoing',
    playerHP: result.newPlayerHP,
    wildHP: result.newWildHP,
    canCatch: result.playerWon
  })

  // If battle ended and player lost, clean up
  if (result.battleEnded && !result.playerWon) {
    this.battleManager.endBattle(playerId)
  }
}

private resolveBattleSummary(battle: ActiveBattle): {
  outcome: 'timeout' | 'win' | 'lose'
  message: string
} {
  // For timeout, auto-resolve based on current HP advantage
  if (battle.status === 'timeout') {
    const playerHpPct = battle.playerHP / battle.playerMaxHP
    const wildHpPct = battle.wildHP / battle.wildMaxHP

    if (playerHpPct > wildHpPct) {
      return {
        outcome: 'win',
        message: `Battle timed out. You won against ${battle.wildPokemon.species.name}!`
      }
    } else {
      return {
        outcome: 'lose',
        message: `Battle timed out. ${battle.wildPokemon.species.name} got away.`
      }
    }
  }

  return { outcome: 'win', message: 'Victory!' }
}
```

Note: Import ActiveBattle type if not already imported: `import type { ActiveBattle } from './battle/battleManager.js'`
  </action>
  <verify>
1. Run `cd apps/game-server && npx tsc --noEmit` to verify compilation
2. Grep for `case 'request_turn':` in hub.ts to confirm handler exists
  </verify>
  <done>Server handles request_turn messages and responds with battle_turn containing single turn data</done>
</task>

<task type="auto">
  <name>Task 4: Modify encounter flow in processTicks to start progressive battles</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
Modify the processTicks method to START progressive battles instead of auto-resolving them.

Integration point: Find `const result = processTick(client.session, this.speciesMap, guildBuffs)` at line ~1352 in processTicks().

The existing encounter handling (lines ~1354-1508) processes `result.encounter` which contains a pre-resolved battle. We need to intercept encounters BEFORE resolution and start progressive battles instead.

**Option A (recommended):** Modify processTick in game.ts to return unresolved encounters when a flag is set. For now, use the existing flow but ADD a parallel `encounter_start` message:

After `const result = processTick(...)` and BEFORE the existing encounter handling block, add:

```typescript
// Progressive battle: Start battle on encounter instead of auto-resolving
// This runs alongside existing logic during transition period
if (result.encounter) {
  const wild = result.encounter.wild_pokemon
  const lead = client.session.party.find(p => p && p.current_hp > 0)

  if (lead) {
    const leadSpecies = this.speciesMap.get(lead.species_id)
    if (leadSpecies) {
      // Start progressive battle (coexists with legacy battle_result)
      const battle = this.battleManager.startBattle(
        client.session.player.id,
        wild,
        lead,
        leadSpecies
      )

      // Send encounter_start for new progressive protocol
      this.sendToClient(client.ws, 'encounter_start', {
        wild_pokemon: wild,
        lead_pokemon: {
          id: lead.id,
          name: leadSpecies.name,
          level: lead.level,
          current_hp: lead.current_hp,
          max_hp: lead.max_hp,
          species_id: lead.species_id,
          is_shiny: lead.is_shiny
        },
        player_first: battle.playerFirst
      })
    }
  }
}
```

Place this code at line ~1353, immediately after `const result = processTick(...)` and BEFORE the `if (result.encounter?.catch_result)` block.

Note: During transition, BOTH the legacy `tick` message (with full battle_result) AND the new `encounter_start` message will be sent. The client chooses which protocol to use. In a future plan, we'll remove the legacy flow.
  </action>
  <verify>
1. Run `cd apps/game-server && npx tsc --noEmit`
2. Grep for `encounter_start` in hub.ts to confirm message is sent
3. Grep for `this.battleManager.startBattle` in processTicks to confirm integration
  </verify>
  <done>Battle starts on encounter via battleManager.startBattle, sends encounter_start message to client</done>
</task>

<task type="auto">
  <name>Task 5: Implement catch-at-throw calculation</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
Add the attempt_catch message handler and its implementation.

1. Find the handleMessage switch statement and add after the request_turn case:
```typescript
case 'attempt_catch':
  this.handleAttemptCatch(client, msg.payload as AttemptCatchPayload)
  break
```

2. Add the handler method to GameHub class:
```typescript
private async handleAttemptCatch(client: Client, payload: AttemptCatchPayload) {
  if (!client.session) return
  const playerId = client.session.player.id

  const battle = this.battleManager.getBattle(playerId)
  if (!battle || battle.status !== 'catching') {
    this.sendToClient(client.ws, 'error', { message: 'Cannot catch - battle not in catching state' })
    return
  }

  const { ball_type } = payload

  // Get ball count from session
  const ballCount = ball_type === 'great_ball'
    ? client.session.great_balls
    : client.session.pokeballs

  if (ballCount <= 0) {
    this.sendToClient(client.ws, 'error', { message: `No ${ball_type}s remaining` })
    return
  }

  // Get guild buff for catch rate
  let catchRateMultiplier = 1.0
  if (client.session.guild?.id) {
    const buffs = await this.getGuildBuffsCached(client.session.guild.id)
    catchRateMultiplier = buffs?.catch_rate?.multiplier || 1.0
  }

  // Import attemptCatch from game.ts
  const { attemptCatch } = await import('./game.js')

  // Calculate catch result NOW (not pre-computed)
  const { result, newBallCount } = attemptCatch(
    battle.wildPokemon,
    ballCount,
    ball_type,
    catchRateMultiplier
  )

  // Update ball count in session
  if (ball_type === 'great_ball') {
    client.session.great_balls = newBallCount
    await updatePlayerGreatBalls(playerId, newBallCount)
  } else {
    client.session.pokeballs = newBallCount
    await updatePlayerPokeballs(playerId, newBallCount)
  }

  // Check if this is a new Pokedex entry
  const caughtSpecies = await getCaughtSpeciesForPlayer(playerId)
  const isNewEntry = !caughtSpecies.has(battle.wildPokemon.species_id)

  // Always show 3 shakes for suspense (per CONTEXT.md decision)
  const shakeCount = 3

  // Send catch result to client
  this.sendToClient(client.ws, 'catch_result', {
    shakeCount,
    success: result.success,
    isNewPokedexEntry: isNewEntry && result.success,
    catchStrength: result.catch_strength || 0.5,
    ball_type,
    pokeballs: client.session.pokeballs,
    great_balls: client.session.great_balls
  })

  if (result.success) {
    // Save caught Pokemon
    const caughtPokemon = await saveCaughtPokemon(
      playerId,
      battle.wildPokemon,
      client.session.zone.id
    )

    // Update Pokedex
    await updatePokedex(playerId, battle.wildPokemon.species_id)

    // Calculate XP for lead Pokemon
    const xpEarned = Math.floor((battle.wildPokemon.species.base_xp_yield * battle.wildPokemon.level) / 7)
    const leadPokemon = client.session.party[0]
    if (leadPokemon) {
      leadPokemon.xp += xpEarned
      await savePokemonXP(leadPokemon.id, leadPokemon.xp)
    }

    // Send catch success with rewards
    this.sendToClient(client.ws, 'catch_complete', {
      caught_pokemon: caughtPokemon,
      xp_earned: xpEarned,
      is_new_pokedex_entry: isNewEntry
    })

    // Record guild activity if in guild
    if (client.session.guild?.id) {
      await recordGuildActivity(client.session.guild.id, 'catch', 1)
    }
  }

  // End battle
  this.battleManager.endBattle(playerId)

  // Set encounter cooldown
  client.session.encounterCooldown = 8  // ENCOUNTER_COOLDOWN_TICKS
}
```

Note: The import of attemptCatch as a dynamic import is to avoid circular dependencies. If this causes issues, move attemptCatch to a separate utils file.
  </action>
  <verify>
1. Run `cd apps/game-server && npx tsc --noEmit`
2. Grep for `case 'attempt_catch':` in hub.ts
3. Grep for `handleAttemptCatch` in hub.ts
  </verify>
  <done>Catch success calculated at throw moment, always shows 3 shakes for suspense, updates Pokedex and XP</done>
</task>

</tasks>

<verification>
1. `cd apps/game-server && npx tsc --noEmit` - Server compiles
2. Grep for `request_turn` in hub.ts - Handler exists
3. Grep for `attempt_catch` in hub.ts - Handler exists
4. Grep for `calculateSingleTurn` in turnCalculator.ts - Function exists
5. Verify battle starts on encounter and sends `encounter_start` message
6. Verify turn is only calculated when `request_turn` received (not pre-computed)
</verification>

<success_criteria>
- Server calculates one turn at a time when client requests it
- Turn result includes battle status (ongoing/player_win/player_faint)
- Catch success calculated at throw moment (not pre-decided)
- Battle timeout auto-resolves based on HP advantage
- Reconnected clients get battle_summary for timed-out battles
- Ball inventory updated on catch attempt
- XP and Pokedex updated on successful catch
</success_criteria>

<output>
After completion, create `.planning/phases/14-battle-system/14-02-SUMMARY.md`
</output>
