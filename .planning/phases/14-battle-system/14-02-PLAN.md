---
phase: 14-battle-system
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - apps/game-server/src/battle/turnCalculator.ts
  - apps/game-server/src/battle/index.ts
  - apps/game-server/src/hub.ts
  - apps/game-server/src/types.ts
autonomous: true

must_haves:
  truths:
    - "Server calculates one turn at a time (not pre-computed bulk)"
    - "Client requests next turn after animation completes"
    - "Battle continues server-side if client disconnects"
    - "Reconnected clients receive battle summary if battle timed out"
  artifacts:
    - path: "apps/game-server/src/battle/turnCalculator.ts"
      provides: "Single-turn calculation extracted from game.ts"
      exports: ["calculateSingleTurn"]
    - path: "apps/game-server/src/hub.ts"
      provides: "Message handlers for progressive battle protocol"
      contains: "request_turn"
  key_links:
    - from: "apps/game-server/src/hub.ts"
      to: "apps/game-server/src/battle/battleManager.ts"
      via: "battleManager.startBattle, updateBattle, endBattle"
      pattern: "this\\.battleManager\\."
    - from: "apps/game-server/src/hub.ts"
      to: "apps/game-server/src/battle/turnCalculator.ts"
      via: "calculateSingleTurn import"
      pattern: "calculateSingleTurn"
---

<objective>
Implement progressive turn calculation and request/response protocol for server-authoritative battles.

Purpose: Replace bulk battle_sequence with turn-by-turn calculation where the client must request each turn. This creates genuine uncertainty since the next turn's outcome is unknown until requested.

Output: Server handles `request_turn` messages and responds with single `battle_turn` messages, calculating each turn only when requested.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-battle-system/14-RESEARCH.md
@.planning/phases/14-battle-system/14-01-SUMMARY.md
@apps/game-server/src/game.ts
@apps/game-server/src/hub.ts
@apps/game-server/src/battle/battleManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract single-turn calculation from game.ts</name>
  <files>apps/game-server/src/battle/turnCalculator.ts, apps/game-server/src/battle/index.ts</files>
  <action>
Create `apps/game-server/src/battle/turnCalculator.ts` that calculates ONE turn at a time:

```typescript
import type { Pokemon, PokemonSpecies, WildPokemon, BattleTurn, Move } from '../types.js'
import { getTypeEffectiveness, calculateDamage } from '../game.js'
import type { ActiveBattle } from './battleManager.js'

// Type effectiveness category
function getEffectivenessCategory(multiplier: number): 'super' | 'neutral' | 'not_very' | 'immune' {
  if (multiplier === 0) return 'immune'
  if (multiplier >= 2) return 'super'
  if (multiplier < 1) return 'not_very'
  return 'neutral'
}

// Move selection (simplified from game.ts - uses first type-matched move)
function selectMove(attackerSpecies: PokemonSpecies, defenderType1: string, defenderType2: string | null): Move {
  const TYPE_MOVE_POOL: Record<string, Move> = {
    NORMAL: { name: 'Tackle', type: 'Normal', power: 40, accuracy: 0.95 },
    FIRE: { name: 'Ember', type: 'Fire', power: 40, accuracy: 1 },
    WATER: { name: 'Water Gun', type: 'Water', power: 45, accuracy: 0.95 },
    GRASS: { name: 'Vine Whip', type: 'Grass', power: 45, accuracy: 0.95 },
    ELECTRIC: { name: 'Spark', type: 'Electric', power: 65, accuracy: 0.9 },
    FLYING: { name: 'Peck', type: 'Flying', power: 35, accuracy: 1 },
    BUG: { name: 'Bug Bite', type: 'Bug', power: 55, accuracy: 0.9 },
    ROCK: { name: 'Rock Throw', type: 'Rock', power: 50, accuracy: 0.9 },
    POISON: { name: 'Poison Sting', type: 'Poison', power: 40, accuracy: 1 },
  }

  const typeKey = attackerSpecies.type1?.toUpperCase() ?? 'NORMAL'
  return TYPE_MOVE_POOL[typeKey] || TYPE_MOVE_POOL.NORMAL
}

export interface TurnResult {
  turn: BattleTurn
  newPlayerHP: number
  newWildHP: number
  battleEnded: boolean
  playerWon: boolean
}

/**
 * Calculate a single battle turn.
 * This is the core function for progressive turn revelation.
 * Called once per client request_turn message.
 */
export function calculateSingleTurn(battle: ActiveBattle): TurnResult {
  const {
    leadPokemon, leadSpecies, wildPokemon,
    playerHP, wildHP, playerMaxHP, wildMaxHP,
    turnNumber, playerFirst
  } = battle

  // Determine who attacks this turn based on turn parity and speed
  const isEvenTurn = turnNumber % 2 === 0
  const playerAttacks = isEvenTurn === playerFirst

  let newPlayerHP = playerHP
  let newWildHP = wildHP
  let turn: BattleTurn

  if (playerAttacks) {
    // Player attacks wild
    const move = selectMove(leadSpecies, wildPokemon.species.type1, wildPokemon.species.type2)
    const typeMultiplier = getTypeEffectiveness(
      leadSpecies.type1,
      wildPokemon.species.type1,
      wildPokemon.species.type2
    )
    const attackStat = Math.max(leadPokemon.stat_attack, leadPokemon.stat_sp_attack)
    const defenseStat = Math.max(wildPokemon.stat_defense, wildPokemon.stat_sp_defense)

    const { damage, isCritical } = calculateDamage(
      leadPokemon.level,
      attackStat,
      defenseStat,
      typeMultiplier,
      move.power
    )

    newWildHP = Math.max(0, wildHP - damage)

    turn = {
      turn_number: turnNumber,
      attacker: 'player',
      attacker_name: leadSpecies.name,
      defender_name: wildPokemon.species.name,
      damage_dealt: damage,
      is_critical: isCritical,
      effectiveness: getEffectivenessCategory(typeMultiplier),
      attacker_hp_after: playerHP,
      defender_hp_after: newWildHP,
      attacker_max_hp: playerMaxHP,
      defender_max_hp: wildMaxHP,
      move_name: move.name,
      move_type: move.type
    }
  } else {
    // Wild attacks player
    const move = selectMove(wildPokemon.species, leadSpecies.type1, leadSpecies.type2)
    const typeMultiplier = getTypeEffectiveness(
      wildPokemon.species.type1,
      leadSpecies.type1,
      leadSpecies.type2
    )
    const attackStat = Math.max(wildPokemon.stat_attack, wildPokemon.stat_sp_attack)
    const defenseStat = Math.max(leadPokemon.stat_defense, leadPokemon.stat_sp_defense)

    const { damage, isCritical } = calculateDamage(
      wildPokemon.level,
      attackStat,
      defenseStat,
      typeMultiplier,
      move.power
    )

    newPlayerHP = Math.max(0, playerHP - damage)

    turn = {
      turn_number: turnNumber,
      attacker: 'wild',
      attacker_name: wildPokemon.species.name,
      defender_name: leadSpecies.name,
      damage_dealt: damage,
      is_critical: isCritical,
      effectiveness: getEffectivenessCategory(typeMultiplier),
      attacker_hp_after: wildHP,
      defender_hp_after: newPlayerHP,
      attacker_max_hp: wildMaxHP,
      defender_max_hp: playerMaxHP,
      move_name: move.name,
      move_type: move.type
    }
  }

  const battleEnded = newPlayerHP <= 0 || newWildHP <= 0
  const playerWon = newWildHP <= 0

  return { turn, newPlayerHP, newWildHP, battleEnded, playerWon }
}
```

Update barrel export in `apps/game-server/src/battle/index.ts`:
```typescript
export { BattleManager, type ActiveBattle } from './battleManager.js'
export { calculateSingleTurn, type TurnResult } from './turnCalculator.js'
```
  </action>
  <verify>Run `cd apps/game-server && npx tsc --noEmit` to verify compilation</verify>
  <done>calculateSingleTurn function exists and computes one turn from ActiveBattle state</done>
</task>

<task type="auto">
  <name>Task 2: Add battle message handlers to hub.ts</name>
  <files>apps/game-server/src/hub.ts, apps/game-server/src/types.ts</files>
  <action>
Add progressive battle message handlers to GameHub.

1. Add import at top:
```typescript
import { calculateSingleTurn } from './battle/index.js'
```

2. Add payload types to types.ts:
```typescript
// Progressive battle payloads
export interface StartBattlePayload {
  // Empty - battle starts automatically from encounter
}

export interface RequestTurnPayload {
  // Empty - server knows which battle from player session
}

export interface AttemptCatchPayload {
  ball_type: BallType
}
```

3. Add message handlers in handleMessage switch statement (after 'get_state' case):
```typescript
case 'request_turn':
  this.handleRequestTurn(client)
  break
case 'attempt_catch':
  this.handleAttemptCatch(client, msg.payload as AttemptCatchPayload)
  break
```

4. Add handler methods to GameHub class:

```typescript
private handleRequestTurn(client: Client) {
  if (!client.session) return
  const playerId = client.session.player.id

  const battle = this.battleManager.getBattle(playerId)
  if (!battle) {
    this.sendToClient(client.ws, 'error', { message: 'No active battle' })
    return
  }

  // Check for timeout
  if (battle.status === 'timeout') {
    // Battle timed out - send summary and clean up
    const summary = this.resolveBattleSummary(battle)
    this.battleManager.endBattle(playerId)
    this.sendToClient(client.ws, 'battle_summary', summary)
    return
  }

  // Calculate next turn
  const result = calculateSingleTurn(battle)

  // Update battle state
  this.battleManager.updateBattle(playerId, {
    playerHP: result.newPlayerHP,
    wildHP: result.newWildHP,
    turnNumber: battle.turnNumber + 1,
    status: result.battleEnded ? (result.playerWon ? 'catching' : 'complete') : 'battling'
  })

  // If player's Pokemon fainted, update HP in session
  if (result.newPlayerHP <= 0 && client.session.party[0]) {
    client.session.party[0].current_hp = 0
  }

  // Send turn to client
  this.sendToClient(client.ws, 'battle_turn', {
    turn: result.turn,
    battleStatus: result.battleEnded ? (result.playerWon ? 'player_win' : 'player_faint') : 'ongoing',
    playerHP: result.newPlayerHP,
    wildHP: result.newWildHP,
    canCatch: result.playerWon
  })

  // If battle ended and player lost, clean up
  if (result.battleEnded && !result.playerWon) {
    this.battleManager.endBattle(playerId)
  }
}

private resolveBattleSummary(battle: ActiveBattle): {
  outcome: 'timeout' | 'win' | 'lose'
  message: string
} {
  // For timeout, auto-resolve based on current HP advantage
  if (battle.status === 'timeout') {
    const playerHpPct = battle.playerHP / battle.playerMaxHP
    const wildHpPct = battle.wildHP / battle.wildMaxHP

    if (playerHpPct > wildHpPct) {
      return {
        outcome: 'win',
        message: `Battle timed out. You won against ${battle.wildPokemon.species.name}!`
      }
    } else {
      return {
        outcome: 'lose',
        message: `Battle timed out. ${battle.wildPokemon.species.name} got away.`
      }
    }
  }

  return { outcome: 'win', message: 'Victory!' }
}
```

5. Modify the existing encounter flow in processTick to START battles instead of resolving them:

Find the section in processTicks where encounters are processed. After the wild Pokemon is generated, instead of calling resolveBattle:

```typescript
// In the encounter processing section, replace battle resolution with battle start:
// OLD: const battleResult = resolveBattle(...)
// NEW: Start progressive battle

const lead = client.session.party.find(p => p && p.current_hp > 0)
if (!lead) {
  // No healthy Pokemon - skip encounter
  continue
}

const leadSpecies = this.speciesMap.get(lead.species_id)
if (!leadSpecies) continue

// Start progressive battle
const battle = this.battleManager.startBattle(
  client.session.player.id,
  wild,  // The generated wild Pokemon
  lead,
  leadSpecies
)

// Send encounter start to client (battle begins, client will request turns)
this.sendToClient(client.ws, 'encounter_start', {
  wild_pokemon: wild,
  lead_pokemon: {
    id: lead.id,
    name: leadSpecies.name,
    level: lead.level,
    current_hp: lead.current_hp,
    max_hp: lead.max_hp,
    species_id: lead.species_id,
    is_shiny: lead.is_shiny
  },
  player_first: battle.playerFirst
})
```

Note: This is a significant change to the tick processing. The existing `result.encounter` handling in handleTick on the client will need updating in Plan 05. For now, send both `encounter_start` (new) and `tick` with encounter data (legacy) to maintain backward compatibility during transition.
  </action>
  <verify>
1. Run `cd apps/game-server && npx tsc --noEmit` to verify compilation
2. Verify request_turn handler exists
3. Verify attempt_catch handler exists (implemented in Task 3)
  </verify>
  <done>Server handles request_turn messages and responds with battle_turn containing single turn data</done>
</task>

<task type="auto">
  <name>Task 3: Implement catch-at-throw calculation</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
Implement the attempt_catch handler that calculates catch success at the moment of throwing (not pre-computed).

Add this method to GameHub class:

```typescript
private async handleAttemptCatch(client: Client, payload: AttemptCatchPayload) {
  if (!client.session) return
  const playerId = client.session.player.id

  const battle = this.battleManager.getBattle(playerId)
  if (!battle || battle.status !== 'catching') {
    this.sendToClient(client.ws, 'error', { message: 'Cannot catch - battle not in catching state' })
    return
  }

  const { ball_type } = payload

  // Get ball count from session
  const ballCount = ball_type === 'great_ball'
    ? client.session.great_balls
    : client.session.pokeballs

  if (ballCount <= 0) {
    this.sendToClient(client.ws, 'error', { message: `No ${ball_type}s remaining` })
    return
  }

  // Get guild buff for catch rate
  let catchRateMultiplier = 1.0
  if (client.session.guild?.id) {
    const buffs = await this.getGuildBuffsCached(client.session.guild.id)
    catchRateMultiplier = buffs?.catch_rate?.multiplier || 1.0
  }

  // Import attemptCatch from game.ts
  const { attemptCatch } = await import('./game.js')

  // Calculate catch result NOW (not pre-computed)
  const { result, newBallCount } = attemptCatch(
    battle.wildPokemon,
    ballCount,
    ball_type,
    catchRateMultiplier
  )

  // Update ball count in session
  if (ball_type === 'great_ball') {
    client.session.great_balls = newBallCount
    await updatePlayerGreatBalls(playerId, newBallCount)
  } else {
    client.session.pokeballs = newBallCount
    await updatePlayerPokeballs(playerId, newBallCount)
  }

  // Check if this is a new Pokedex entry
  const caughtSpecies = await getCaughtSpeciesForPlayer(playerId)
  const isNewEntry = !caughtSpecies.has(battle.wildPokemon.species_id)

  // Always show 3 shakes for suspense (per CONTEXT.md decision)
  const shakeCount = 3

  // Send catch result to client
  this.sendToClient(client.ws, 'catch_result', {
    shakeCount,
    success: result.success,
    isNewPokedexEntry: isNewEntry && result.success,
    catchStrength: result.catch_strength || 0.5,
    ball_type,
    pokeballs: client.session.pokeballs,
    great_balls: client.session.great_balls
  })

  if (result.success) {
    // Save caught Pokemon
    const caughtPokemon = await saveCaughtPokemon(
      playerId,
      battle.wildPokemon,
      client.session.zone.id
    )

    // Update Pokedex
    await updatePokedex(playerId, battle.wildPokemon.species_id)

    // Calculate XP for lead Pokemon
    const xpEarned = Math.floor((battle.wildPokemon.species.base_xp_yield * battle.wildPokemon.level) / 7)
    const leadPokemon = client.session.party[0]
    if (leadPokemon) {
      leadPokemon.xp += xpEarned
      await savePokemonXP(leadPokemon.id, leadPokemon.xp)
    }

    // Send catch success with rewards
    this.sendToClient(client.ws, 'catch_complete', {
      caught_pokemon: caughtPokemon,
      xp_earned: xpEarned,
      is_new_pokedex_entry: isNewEntry
    })

    // Record guild activity if in guild
    if (client.session.guild?.id) {
      await recordGuildActivity(playerId, 'catch', {
        species_id: battle.wildPokemon.species_id,
        is_shiny: battle.wildPokemon.is_shiny
      })
    }
  }

  // End battle
  this.battleManager.endBattle(playerId)

  // Set encounter cooldown
  client.session.encounterCooldown = 8  // ENCOUNTER_COOLDOWN_TICKS
}
```

Note: The import of attemptCatch as a dynamic import is to avoid circular dependencies. If this causes issues, move attemptCatch to a separate utils file.
  </action>
  <verify>
1. Run `cd apps/game-server && npx tsc --noEmit`
2. Verify handleAttemptCatch method exists
3. Verify it uses attemptCatch from game.ts for catch calculation
  </verify>
  <done>Catch success calculated at throw moment, always shows 3 shakes for suspense, updates Pokedex and XP</done>
</task>

</tasks>

<verification>
1. `cd apps/game-server && npx tsc --noEmit` - Server compiles
2. Grep for `request_turn` in hub.ts - Handler exists
3. Grep for `attempt_catch` in hub.ts - Handler exists
4. Grep for `calculateSingleTurn` in turnCalculator.ts - Function exists
5. Verify battle starts on encounter and sends `encounter_start` message
6. Verify turn is only calculated when `request_turn` received (not pre-computed)
</verification>

<success_criteria>
- Server calculates one turn at a time when client requests it
- Turn result includes battle status (ongoing/player_win/player_faint)
- Catch success calculated at throw moment (not pre-decided)
- Battle timeout auto-resolves based on HP advantage
- Reconnected clients get battle_summary for timed-out battles
- Ball inventory updated on catch attempt
- XP and Pokedex updated on successful catch
</success_criteria>

<output>
After completion, create `.planning/phases/14-battle-system/14-02-SUMMARY.md`
</output>
