---
phase: 14-battle-system
plan: 05
type: execute
wave: 3
depends_on: ["14-04"]
files_modified:
  - apps/game-server/src/hub.ts
  - apps/game-server/src/game.ts
  - apps/web/src/lib/ws/gameSocket.ts
autonomous: true

must_haves:
  truths:
    - "Battles timeout after 30 seconds if client disconnects"
    - "Disconnected battles auto-resolve on server"
    - "Reconnected clients receive battle summary"
    - "Encounter cooldown starts after battle ends"
  artifacts:
    - path: "apps/game-server/src/hub.ts"
      provides: "Disconnect handling for active battles"
      contains: "handleDisconnect"
  key_links:
    - from: "apps/game-server/src/hub.ts"
      to: "apps/game-server/src/battle/battleManager.ts"
      via: "battleManager.endBattle on disconnect"
      pattern: "this\\.battleManager\\.endBattle"
---

<objective>
Implement battle timeout, disconnect handling, and reconnection flow for robust server-authoritative battles.

Purpose: Ensure battles don't hang forever if clients disconnect, auto-resolve based on HP advantage, and provide summary to reconnecting clients.

Output: 30-second timeout enforced, disconnected battles resolved, reconnected clients informed of outcome.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-battle-system/14-RESEARCH.md
@.planning/phases/14-battle-system/14-04-SUMMARY.md
@apps/game-server/src/hub.ts
@apps/game-server/src/battle/battleManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add battle cleanup on client disconnect</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
Update handleDisconnect to properly handle active battles.

Find the handleDisconnect method in GameHub class and add battle cleanup:

```typescript
private handleDisconnect(client: Client) {
  // ... existing cleanup code ...

  // Clean up active battle if exists
  if (client.session) {
    const playerId = client.session.player.id
    const battle = this.battleManager.getBattle(playerId)

    if (battle && battle.status !== 'complete') {
      console.log(`[Battle] Client ${playerId} disconnected with active battle - marking for timeout`)
      // Don't end immediately - let timeout handle it for reconnect opportunity
      // The BattleManager cleanup interval will mark it as 'timeout' after 30 seconds
      // If player reconnects before timeout, they can continue
    }
  }

  // ... rest of existing cleanup ...
}
```

Note: The battle is NOT ended immediately. This allows the player to reconnect within 30 seconds and continue. The BattleManager's cleanup interval will mark it as 'timeout' if no activity for 30 seconds.
  </action>
  <verify>Run `cd apps/game-server && npx tsc --noEmit`</verify>
  <done>Disconnect handling logs battle state and allows 30-second reconnect window</done>
</task>

<task type="auto">
  <name>Task 2: Add reconnect battle resume/summary logic</name>
  <files>apps/game-server/src/hub.ts</files>
  <action>
When a player reconnects (handleConnection completes loadSession), check for existing battle state and send appropriate message.

Add this method to GameHub class:

```typescript
private async checkAndResumeActiveBattle(client: Client) {
  if (!client.session) return
  const playerId = client.session.player.id

  const battle = this.battleManager.getBattle(playerId)
  if (!battle) return

  // Check if battle timed out while disconnected
  if (battle.status === 'timeout') {
    // Auto-resolve and send summary
    const summary = this.resolveBattleSummary(battle)

    // Apply results
    if (summary.outcome === 'win') {
      // Player won - give XP but no catch (timed out during catch)
      const xpEarned = Math.floor((battle.wildPokemon.species.base_xp_yield * battle.wildPokemon.level) / 7)
      const leadPokemon = client.session.party[0]
      if (leadPokemon) {
        leadPokemon.xp += xpEarned
        await savePokemonXP(leadPokemon.id, leadPokemon.xp)
      }
    } else if (summary.outcome === 'lose') {
      // Player lost - apply HP damage to lead Pokemon
      if (client.session.party[0]) {
        client.session.party[0].current_hp = 0
        await updatePokemonHP(client.session.party[0].id, 0)
      }
    }

    // Clean up battle
    this.battleManager.endBattle(playerId)

    // Set encounter cooldown
    client.session.encounterCooldown = 8

    // Send summary to client
    this.sendToClient(client.ws, 'battle_summary', summary)
    return
  }

  // Battle still active - send current state so client can resume
  this.sendToClient(client.ws, 'encounter_start', {
    wild_pokemon: battle.wildPokemon,
    lead_pokemon: {
      id: battle.leadPokemon.id,
      name: battle.leadSpecies.name,
      level: battle.leadPokemon.level,
      current_hp: battle.playerHP,
      max_hp: battle.playerMaxHP,
      species_id: battle.leadPokemon.species_id,
      is_shiny: battle.leadPokemon.is_shiny
    },
    player_first: battle.playerFirst,
    resume: true,  // Flag that this is a resume, not new battle
    current_turn: battle.turnNumber,
    player_hp: battle.playerHP,
    wild_hp: battle.wildHP,
    status: battle.status
  })

  console.log(`[Battle] Client ${playerId} reconnected - resuming battle at turn ${battle.turnNumber}`)
}
```

Call this method after loadSession succeeds in handleConnection:

```typescript
// In handleConnection, after sendGuildData:
await this.checkAndResumeActiveBattle(client)
```

Add the import at top for updatePokemonHP and savePokemonXP if not already present:
```typescript
import { updatePokemonHP, savePokemonXP } from './db.js'
```
  </action>
  <verify>Run `cd apps/game-server && npx tsc --noEmit`</verify>
  <done>Reconnected clients receive battle_summary if timed out, or encounter_start with resume flag if still active</done>
</task>

<task type="auto">
  <name>Task 3: Handle battle resume on client</name>
  <files>apps/web/src/lib/ws/gameSocket.ts</files>
  <action>
Update handleEncounterStart to handle resumed battles.

Update the handleEncounterStart handler:

```typescript
private handleEncounterStart = (payload: unknown) => {
  const data = payload as {
    wild_pokemon: WildPokemon
    lead_pokemon: {
      id: string
      name: string
      level: number
      current_hp: number
      max_hp: number
      species_id: number
      is_shiny: boolean
    }
    player_first: boolean
    resume?: boolean
    current_turn?: number
    player_hp?: number
    wild_hp?: number
    status?: string
  }

  const store = useGameStore.getState()

  // If resuming, use server's HP values
  const playerHP = data.resume ? (data.player_hp ?? data.lead_pokemon.current_hp) : data.lead_pokemon.current_hp
  const wildHP = data.resume ? (data.wild_hp ?? data.wild_pokemon.max_hp) : data.wild_pokemon.max_hp

  // Determine initial status
  const status = data.resume && data.status === 'catching' ? 'catching' : 'intro'

  store.setActiveBattle({
    wildPokemon: data.wild_pokemon,
    leadPokemon: data.lead_pokemon,
    playerFirst: data.player_first,
    status,
    currentTurn: null,
    playerHP,
    wildHP,
    playerMaxHP: data.lead_pokemon.max_hp,
    wildMaxHP: data.wild_pokemon.max_hp
  })

  if (data.resume) {
    console.log(`[Battle] Resuming battle at turn ${data.current_turn}, status: ${data.status}`)

    // If battle was in catching state, auto-trigger catch sequence
    if (data.status === 'catching') {
      // Determine ball type and attempt catch
      const inventory = store.inventory
      const ballType = (inventory.great_ball || 0) > 0 ? 'great_ball' : 'pokeball'
      gameSocket.attemptCatch(ballType)
    } else {
      // Request next turn to resume battle
      gameSocket.requestTurn()
    }
  }
}
```

Note: Self-reference to gameSocket works because it's a singleton. If this causes issues, use setTimeout to defer the call.
  </action>
  <verify>Run `cd apps/web && npx tsc --noEmit`</verify>
  <done>Client handles resumed battles by restoring HP state and requesting next action</done>
</task>

</tasks>

<verification>
1. `cd apps/game-server && npx tsc --noEmit` - Server compiles
2. `cd apps/web && npx tsc --noEmit` - Client compiles
3. Verify handleDisconnect references battleManager
4. Verify checkAndResumeActiveBattle is called in handleConnection
5. Verify handleEncounterStart handles resume flag
6. Verify encounter cooldown set after battle ends
</verification>

<success_criteria>
- Battles timeout after 30 seconds of client inactivity
- Timed out battles resolve based on HP advantage (higher HP wins)
- Disconnected clients can reconnect within 30 seconds and continue
- Reconnected clients after timeout receive battle_summary with outcome
- XP applied for timeout wins, HP damage applied for timeout losses
- Encounter cooldown prevents immediate new encounters after battle
</success_criteria>

<output>
After completion, create `.planning/phases/14-battle-system/14-05-SUMMARY.md`
</output>
